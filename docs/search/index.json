[{"content":"遊戲中的碰撞檢測Collision Detection 前言 而這篇文有三個主要目的 :\n 對遊戲中的碰撞感興趣，卻不會寫程式的人可以了解原理 讓有能力實作的人，可以跟著文章寫出精確的多邊形碰撞檢測 自己的學習筆記  讓我們開始吧。\n這次要來介紹的主題是分離軸碰撞檢測(Separating Axis Theorem, SAT)\n分離軸定理通常用語檢測兩個多邊形或多邊形與圓之間的碰撞，跟所有演算法一樣他具有一定的優勢與缺點。\n我會慢慢講解背後的原理，並使用程式碼做簡易的範例。\n範例所使用的語言為Java Script，加上自製的向量函式庫，但我想觀念懂了應該不會有太大問題。\n矩形碰撞檢測 我想先從最簡單的碰撞檢測開始講，這樣比較好讓各位了解為什麼需要分離軸檢測，所以先從一般的矩形碰撞開始。\nAABB碰撞檢測(Axis-aligned Bounding Box): 為了方邊物體之間進行碰撞檢測運算，通常會對物體創建一個長方形將其包圍，AABB包圍盒也被稱為軸對齊包圍盒。\n一般二維的AABB包圍盒具備兩項特點:\n 以矩形包圍物體 矩形的每條邊，皆與坐標系的軸垂直  簡單來說就是用矩形把物體包起來，檢查矩形之間是否發生碰撞\n如下圖，黑框及為包圍盒，在做碰撞檢測時，只需要檢查包圍盒之間是否發生碰撞:\n AABB碰撞盒中的物體 \n那我們就直接來看看AABB碰撞盒是如何運作的吧。\n這裡有兩個矩形A、B，Box A最小邊為A.min、最大邊為A.max，而Box B同理。\n A.max \u0026lt; B.min \n如上圖所示，當A.max \u0026lt; B.min時，代表兩物體之間仍有縫隙，沒有發生碰撞。\n A.max \u0026gt; B.min \n上圖可以明顯地看到A與B發生碰撞，當A.max \u0026gt; B.min時，代表兩物體之間沒有縫隙，發生碰撞。\n B.max \u0026gt; A.min \n但前面只討論B在A右側，當B在A的左側時，條件就要稍微改一下，當B在A的左側時，B.max \u0026gt; A.min時發生碰撞。\n將兩張圖的結果合在一起，整理成code:\nif (A.max \u0026gt; B.min \u0026amp;\u0026amp; B.max \u0026gt; A.min) Console.log(\u0026#34;Collided\u0026#34;); 為什麼使用 AND 來判斷?\n只要A在B的右邊，那麼A.max就會永遠大於B.min，因為A.max \u0026gt; B.min是用在A在左邊的碰撞判斷，所以只要沒有發生碰撞，就代表只有一個條件會是True，碰撞無法成立，所以使用 AND。\n那麼當A在B的上面或下面呢?\n 複合情況 \n方法是一樣，對Y軸上的min、max判斷即可。\n讓我們對著圖片來看程式碼 :\nfunction RectCollision(r1, r2) { // 這邊因為(X,Y)在方塊中心，所以在取得min、max時，要 +/- width/2  // Rect1  var minX1 = r1.x - r1.width / 2, maxX1 = r1.x + r1.width / 2, minY1 = r1.y - r1.height / 2, maxY1 = r1.y + r1.height / 2; // Rect2  var minX2 = r2.x - r2.width / 2, maxX2 = r2.x + r2.width / 2, minY2 = r2.y - r2.height / 2, maxY2 = r2.y + r2.height / 2; if (maxX1 \u0026gt; minX2 \u0026amp;\u0026amp; maxX2 \u0026gt; minX1 \u0026amp;\u0026amp; maxY1 \u0026gt; minY2 \u0026amp;\u0026amp; maxY2 \u0026gt; minY1) { return true; } else return false; } // 完整原始碼在結尾與感想的最後。 測試結果:  矩形AABB結果 \n那麼另外一種情況如何?  出現旋轉的情況  如上圖，我們能明顯的看出兩物體沒有發生碰撞，但是用AABB碰撞檢測，答案卻是…發生碰撞。\nAABB碰撞檢測算法雖然計算方法簡單、速度快，但卻有幾個問題:\n 當物體旋轉時就無法檢查 只能檢查矩型物體  那麼要如何解決這兩個問題呢?\n就是本文的主題「SAT碰撞檢測」，這個方法可以完美的解決這兩個問題。\n讓我們進入下一階段。\n什麼是分離軸檢測? 如果有兩個凸多邊形，在任意角度下的投影皆有重疊，代表物體發生碰撞，否則只要有縫隙，就代表沒有碰撞。\n 投影之間有縫隙 \n簡單來說，就是如果能在兩個物體間找到一條線來分離它們，那麼就代表這兩個物體之間沒有發生碰撞。\n 常見狀況 \n上圖中你可以看到第一排的物體之間有縫隙，所以能夠輕鬆地畫出一條線來分離它們，但第二排就沒辦法，因為這兩個物體已經相撞，之間沒有縫隙，所以找不出一條線來當分離線。\n而分離線不只一條 :\n 沒有發生碰撞的物體之間，有無限多分離線 \n到目前為止已經大概了解什麼是分離線，那要如何利用分離線來做碰撞檢測? 很簡單，只要檢查兩物體之間是否存在分離線即可，因為只要找到一條分離線就代表物體之間有縫隙，表示沒有發生碰撞。\n 分離軸與分離線 \n而所謂的分離軸就是與分離線垂直的一條線，透過分離軸上物體的投影是否重疊，來判斷是否發生碰撞。\n所以我們能透過分離軸檢查旋轉的物體。\n 物體在P向量上的投影 \n假設向量P是45度的延長線，由上圖可知，如果我們將A、B的「四個角投影在P向量上」，可以得到它們的min、max，接下來就能透過min、max來判斷碰撞。\n這時應該會有幾個問題:\n 如何取得分離軸上的投影min、max? 如何取得分離軸P?  但是在解決那兩個問題前，先來看看前面這段話「四個角投影在P向量上」:\n 要如何取得旋轉後的4個角? 要如何計算其中一個角落在P向量上的投影?  所以在前往下一個階段之前，要先補充一些數學的知識。\n知識補充1–向量 知識補充1與2這兩段，可以先跳過，不影響閱讀，等到有看不懂的地方再回來看也行。\n為了解釋如何取得投影與分離軸，所以需要先補充向量的知識。\n數學向量忘記的話，這裡推薦幾部教學影片:\n南投高中數學課 : 向量內積公式說明、單位向量的說明\nQ仔高中數學教室 : 向量的內積、向量內積的幾何意義與座標表示法\n向量的內積:  A與B的內積 \n我們可以透過兩向量之間的夾角來計算點積: $$ A\\cdot B=\\left | A \\right |\\left | B \\right |cos \\theta $$ 或使用座標來計算: $$ \\vec{A}\\cdot \\vec{B}=A_{x}B_{x}+A_{y}B_{y} $$ 有了這兩個公式後，就可以開始來證明文章需要的公式了\n正射影 :  A在B上的投影  $$ A\\cdot B=\\left | A \\right |\\left | B \\right |cos \\theta $$ $$ cos \\theta = \\frac{A\\cdot B}{\\left | \\vec{A} \\right |\\left | \\vec{B} \\right |}=\\frac{\\left |\\vec{P} \\right |}{\\left |\\vec{A} \\right |} $$ 然後我們就會得到向量P的長度 $$ \\left |\\vec{P} \\right |=\\frac{(\\vec{A} \\cdot \\vec{B})\\left |\\vec{A} \\right |}{\\left |\\vec{A} \\right |\\left |\\vec{B} \\right |}=\\frac{\\vec{A}\\cdot \\vec{B}}{\\left |\\vec{B} \\right |} $$ 但這裡求出的P是長度(正射影長)，只有大小，沒有方向\n回到上圖可以觀察出P向量的方向是延著B向量，所以只要讓 純量P 乘上 單位向量B，就能得到A在B上的正射影。 $$ \\vec{P} = \\frac{\\vec{A} \\cdot \\vec{B}}{\\left | \\vec{B} \\right |}\\ast \\frac{\\vec{B}}{\\left | \\vec{B} \\right |}=\\frac{(\\vec{A} \\cdot \\vec{B})\\vec{B}}{\\left | \\vec{B} \\right |^{2}} $$\n所謂的單位向量就是大小為1的方向向量，而純量只有大小，兩個相乘即可得到長度為P且方向為B的向量 (如果還是不太懂的話可以自己畫圖證明看看)。\n所以正射影是A向量在B向量上的分量。\n了解正射影後，就能取得物體在分離軸上的投影了。\n法向量 : 定義:垂直於平面的向量。\n$$ \\vec{A}\\cdot \\vec{B}=A_{x}B_{x}+A_{y}B_{y} $$\n從點積公式可以得出，當兩向量垂直時，向量內積會是零。\n假設A向量為(3, 4)，求A的法向量，那麼我們只要將A帶進去，並湊一個能滿足等式為零的參數就是法向量。\n$$ (3)(B_{x}) + (4)(B_{y}) = 0 $$\n這時B向量會有無限多組合，但是有其中兩組(4, -3)、(-4, 3)，剛好就是A向量的座標互換並加負號。\n所以我們可以得到下圖結果:  向量P的左/右法向量 \n了解如何取得法向量後，就能取得需要檢查的分離軸了。\n有了向量、內積、正射影長、法向量這些基本資訊後，先來建立一個簡易的向量函式庫吧\nfunction Vector(x, y) { this.x = x; this.y = y; } // 取得這個自己的長度 Vector.prototype.length = function () { return Math.sqrt(this.x * this.x + this.y * this.y); } // 取得自己與vec2的內積 Vector.prototype.dot = function (vec2) { return this.x * vec2.x + this.y * vec2.y; } // 取得自己在vec2上的正射影長 Vector.prototype.projectLengthOnto = function (vec2) { var dotProduct = this.dot(vec2); var len = vec2.length(); return dotProduct / len; } // 取得自己的左法向量 Vector.prototype.normalL = function () { return new Vector(-this.y, this.x); } // 取得自己的右法向量 Vector.prototype.normalR = function () { return new Vector(this.y, -this.x); } 使用方式:\nvar vec1 = new Vector(3, 4);// 建立vec1向量 var vec2 = new Vector(1, 0);// 建立vec2向量 vec1.length() // =\u0026gt; 5 vec1.dot(vec2) // =\u0026gt; 3 vec1.projectLengthOnto(vec2) // =\u0026gt;3 vec1.normalL() // = (-4, 3) vec1.normalR() // = (4, -3) 知識補充2–旋轉變換 為了解釋如何取得物體旋轉後的角落，所以需要先補充旋轉變換的知識。\n其作用為以原點為中心旋轉θ角:  將P繞著O旋轉θ角至P' \n如上圖，座標平面上$L = \\overline{OP}$ 且點$P(x_{1}, y_{1})$滿足$x_{1} = L*\\cos \\alpha, y_{1} = L*\\sin \\alpha$\n那麼，以原點O為中心，將這個點以逆時針旋轉 $\\theta$角後得到${P}'(x_{2}, y_{2})$\n方法一:\n先取得$\\overline{OP}$與$\\alpha$，那麼${P}'$就是$( L*\\cos (\\alpha +\\theta ), L*\\sin (\\alpha +\\theta ) )$\n但在電腦中取得OP長要透過畢氏定理開根號來取得，加上只有P點不知道α角的時候，要用Math.atan2(y, x)先取得α的角度後再計算，比較麻煩。\n所以有一個改良版:  透過和角公式改良 \n和角公式:\n$$ \\begin{cases} \\cos(\\alpha+\\theta )= \\cos \\alpha \\cos \\theta - \\sin \\alpha \\sin \\theta \\\\ \\sin(\\alpha+\\theta ) = \\sin \\alpha\\cos \\theta + \\cos \\alpha\\sin \\theta \\end{cases} $$\n所以\n$$ \\begin{cases} \\cos(\\alpha+\\theta ) = \\frac{x_{2}}{L} = \\frac{x_{1}}{L}\\times \\cos\\theta - \\frac{y_{1}}{L} \\times \\sin\\theta \\\\ \\sin(\\alpha+\\theta ) = \\frac{y_{2}}{L} = \\frac{y_{1}}{L}\\times \\cos\\theta - \\frac{x_{1}}{L} \\times \\sin\\theta \\end{cases} $$\n同乘L後即可得到 $$ \\begin{cases} x_{2}= x_{1}\\cos \\theta-y_{1} \\sin\\theta \\\\ y_{2}= y_{1}\\cos \\theta+x_{1} \\sin\\theta \\end{cases} $$\n而這個就是我們要的旋轉公式\n矩陣表示法:\n$$ \\begin{bmatrix} x_{2} \\\\ y_{2} \\end{bmatrix} = \\begin{bmatrix}\\cos \\theta \u0026amp; - \\sin \\theta \\\\ \\sin \\theta \u0026amp; \\cos \\theta \\end{bmatrix}\\begin{bmatrix} x_{1} \\\\ y_{1} \\end{bmatrix} $$\n而這矩陣就是所謂的旋轉矩陣，未來電腦圖學會很常用到。\n講解完後，把這段公式加入我們的向量函式庫吧。\nangle為弧度，並以原點(0,0)為中心旋轉angle角:\nVector.prototype.rotate = function (angle) { var new_x = (this.x * Math.cos(angle)) - (this.y * Math.sin(angle)); var new_y = (this.x * Math.sin(angle)) + (this.y * Math.cos(angle)); this.x = new_x; this.y = new_y; } 如何取得分離軸上的投影? 有了投影公式後，接下來只要把A、B的四個角投影在P向量上就能知道min、max了。\n \n這時卻出現了一個狀況，如果兩個物體方向不一樣呢?\n \n由上圖可知，當兩物體方向不同時，只要在4個角落中選一個最小和最大的，就是min、max。\n那我們要如何透過投影來判斷碰撞?\n \n由上圖可以看到，A.max、B.min在P向量上的投影圖。\n當B.min \u0026gt; A.max時，代表他們之間有分離線，所以沒有碰撞。當位置交換時，A.min \u0026gt; B.max時代表有間距。\n讓我們把結果整理成code :\nif (B.min \u0026gt; A.max || A.min \u0026gt; B.max) Console.log(\u0026#34;分離\u0026#34;);// isSeparated else Console.log(\u0026#34;碰撞\u0026#34;);// isCollided 這邊選擇True為分離是因為這是分離軸檢測，我認為這樣比較符合。\n了解如何取得min、max，並如何判斷後，就可以進入下個階段了。\n編寫程式碼-投影、旋轉與判斷 第一步，我們需要取得矩形上的四個角，這時就需要前面的「知識補充2-旋轉變換」\n 不如預期的旋轉 \n如果直接將四個角套用旋轉公式的話，就會像左圖一樣，物體繞中心旋轉。\n但我們想要的是右圖中，物體原地旋轉的效果，所以要將旋轉公式做點更動。\n 先平移旋轉後再平移 \n如上圖的步驟，我們需要的旋轉是以矩形中心為參考點做旋轉，而原公式以原點做旋轉，所以需要先將物體平移到原點，旋轉完後再將其平移回來。\n 正確的繞中心旋轉 \n$$ \\begin{cases} x_{1}' = [(x_{1}-x_{0})\\cos\\theta-(y_{1}-y_{0})\\sin\\theta] + x_{0} \\\\ y_{1}' = [(y_{1}-y_{0})\\cos\\theta+(x_{1}-x_{0})\\sin\\theta] + y_{0} \\end{cases} $$\n把這個公式加入向量函式庫:\n// angle:弧度, refP:參考點 // 作用: 以refP為參考點，旋轉angle角 Vector.prototype.rotateRefPoint = function (angle, refP) { let new_x = (this.x - refP.x) * Math.cos(angle) - (this.y - refP.y) * Math.sin(angle) + refP.x; let new_y = (this.y - refP.y) * Math.cos(angle) + (this.x - refP.x) * Math.sin(angle) + refP.y; this.x = new_x; this.y = new_y; } 然後讓我們來建立一個基本的物體:\n先簡單寫出Box的結構\nfunction Box(x, y, w, h) { this.pos = new Vector(x, y);// 中心  this.w = w; this.h = h; // 以順時針紀錄矩形的四個角  this.corners = [ new Vector(w / 2, -h / 2), new Vector(w / 2, h / 2), new Vector(-w / 2, h / 2), new Vector(-w / 2, -h / 2) ]; // 假設角度是45  this.directionAngle = toRadio(45);// 將45換成弧度  this.getVertices = function () { var vertices = []; // 順時針走訪角落  for (var i = 0; i \u0026lt; this.corners.length; i++) { var p1 = this.corners[i]; var vec = new Vector(this.pos.x + p1.x, this.pos.y + p1.y); // 將各個角以物體中心為參考點來旋轉  vec.rotateRefPoint(this.directionAngle, this.pos); vertices.push(vec); } // 最後回傳以物體中心為參考點選轉後的角落  return vertices; } } 接下來只要呼叫getVertices()就能取得旋轉後四個角的陣列了 :\n// 取得box1的4個角 var boxA_Vertices = boxA.getVertices(); 第二步，參考\u0026quot;如何取得分離軸上的投影\u0026quot;的說明，取得box1在分離軸上的min、max投影。而box2也是一樣的方法 :\n// 假設分離軸為45度角 var axis = new Vector(1, -1); // 取得box1的4個角 var boxA_Vertices = box1.getVertices(); // 先以第一個角當初始值 // vec.projectLengthOnto(axis) : 取得vec在axis上的投影長 var min_proj_boxA = boxA_Vertices[0].projectLengthOnto(axis); var min_index_boxA = 0; var max_proj_boxA = boxA_Vertices[0].projectLengthOnto(axis); var max_index_boxA = 0; // 再從剩下的3個角選出最大和最小投影 for (var i = 1; i \u0026lt; 4; i++) { var current = boxA_Vertices[i].projectLengthOnto(axis); // 選擇最小投影  if (current \u0026lt; min) { min_proj_boxA = current; min_index_boxA = i; } // 選擇最大投影  if (current \u0026gt; max) { max_proj_boxA = current; max_index_boxA = i; } }  \n最後，當我們有了box1和box2的min、max後，就可以檢查他們是否在axis這個軸上碰撞\nif (min_proj_boxB \u0026gt; max_proj_boxA || min_proj_boxA \u0026gt; max_proj_boxB) Console.log(\u0026#34;分離\u0026#34;);// isSeparated else Console.log(\u0026#34;碰撞\u0026#34;);// isCollided 讓我們把剛剛\u0026quot;第二步\u0026quot;的min、max取得整理一下，變成可呼叫的方法:\n// getMinMax(頂點陣列,分離軸) function getMinMax(vertices, axis) { // 先以第一個角落投影為標準  var min_DotProduct = vertices[0].projectLengthOnto(axis), max_DotProduct = vertices[0].projectLengthOnto(axis); for (var i = 1; i \u0026lt; vertices.length; i++) { // 取得當前要比對的投影長度  var temp = vertices[i].projectLengthOnto(axis); // 如果比當前最小的更小，紀錄它  if (temp \u0026lt; min_DotProduct) { min_DotProduct = temp; min_index = i; } // 如果比當前最小的更大，紀錄它  if (temp \u0026gt; max_DotProduct) { max_DotProduct = temp; max_index = i; } } var result = { min: min_DotProduct, max: max_DotProduct }; // 最後傳回一個物件包含min、max屬性  return result; } 如何取得分離軸? 在SAT介紹的時候也提到，兩物體間有無限多條分離軸，難不成要真的從0度~360度的分離軸全部投影一變嗎?\n其實不需要，我們只需要沿著物體所有邊上的法向量當作分離軸作檢查，即可判斷。\n \n由上圖可知，如果我們將三角形向左平移，直到與五角形投影重疊時，代表他們發生碰撞。\n而綠色那條分離線，可以當作五角形守備的領域，只要有東西進到這裡，就代表碰撞。\n 五角形需要的分離軸為綠色虛線 \n如上圖，將五角形每個邊上的檢查線都畫出來後，只要取跟檢查線垂直的軸，就是我們需要的分離軸。\n只要有任何物體進入綠色分離線的包圍區，就代表物體與五角形發生碰撞。\n那麼要如何取得邊上的法向量?\n這時候就是補充知識1-法向量派上用場的時候了。\n 正方形的邊法向量 \n如上圖，對每個邊向量取法向量即可，而我這邊以順時針、取左法向量為例子。\n可以發現，在矩形中會有兩組方向相反的法向量，所以可以透過優化找出重複的法向量增加效率，但通常只對矩形有效果。\n先讓讓我們在Box物件中再加入getNorms()這個方法 :\nfunction Box(x, y, w, h) { // ...省略...  this.getNorms = function () { var vertices = this.getVertices();// 取得頂點  var norms = []; var p1, p2, n; // 順時鐘  for (let i = 1; i \u0026lt; vertices.length; i++) { p1 = vertices[i - 1]; p2 = vertices[i]; // 取得這個邊的左法向量  n = new Vector(p2.x - p1.x, p2.y - p1.y).normalL(); // 加入這個法向量  norms.push(n); } // 補上最後一個邊  p1 = vertices[vertices.length - 1]; p2 = vertices[0]; n = new Vector(p2.x - p1.x, p2.y - p1.y).normalL(); norms.push(n); // 最後傳回這個物體所有邊上的左法向量  return norms; } } 有了頂點取得的方式、投影大小的判斷加上邊上法向量的取得，我相信你已經有足夠的知識來完成SAT碰撞檢測了。\n粗糙的矩形檢測 讓我們來看看針對矩形的程式碼，這段程式碼單純是了解檢查過程，如果你對判斷的方法不是很清楚的話希望你花一些時間看一下，後面會在寫出一個整理過的寫法。\n 實際應用在旋轉中的矩形 \n這裡我假設A方塊的法向量是P、Q，B方塊的法向量是S、R，手動對它們一一檢查\nfunction SAT_Collision(boxA, boxB) { var vertices_boxA = boxA.getVertices(); var vertices_boxB = boxB.getVertices(); var norms_boxA = boxA.getNorm(); var norms_boxB = boxB.getNorm(); // 假設boxA的法向量為P、Q，boxB為R、S  // boxA、boxB在P、Q檢查軸上的投影  var MinMax_PA = getMinMax(vertices_boxA, norms_boxA[0]); var MinMax_PB = getMinMax(vertices_boxB, norms_boxA[0]); var MinMax_QA = getMinMax(vertices_boxA, norms_boxA[1]); var MinMax_QB = getMinMax(vertices_boxB, norms_boxA[1]); // boxA、boxB在R、S檢查軸上的投影  var MinMax_RA = getMinMax(vertices_boxA, norms_boxB[0]); var MinMax_RB = getMinMax(vertices_boxB, norms_boxB[0]); var MinMax_SA = getMinMax(vertices_boxA, norms_boxB[1]); var MinMax_SB = getMinMax(vertices_boxB, norms_boxB[1]); // 在分離軸上是否分離  var separate_P = MinMax_PB.min_proj \u0026gt; MinMax_PA.max_proj || MinMax_PA.min_proj \u0026gt; MinMax_PB.max_proj; var separate_Q = MinMax_QB.min_proj \u0026gt; MinMax_QA.max_proj || MinMax_QA.min_proj \u0026gt; MinMax_QB.max_proj; var separate_R = MinMax_RB.min_proj \u0026gt; MinMax_RA.max_proj || MinMax_RA.min_proj \u0026gt; MinMax_RB.max_proj; var separate_S = MinMax_SB.min_proj \u0026gt; MinMax_SA.max_proj || MinMax_SA.min_proj \u0026gt; MinMax_SB.max_proj; var isSeparated = separate_P || separate_Q || separate_R || separate_S; if(isSeparated) Console.log(\u0026#34;分離\u0026#34;);// isSeparated  else Console.log(\u0026#34;碰撞\u0026#34;);// isCollided } 測試結果:\n 兩個旋轉矩形的碰撞檢測 \n但上面那個只適用在矩形上，而且Code又醜又長，所以把它整理一下。\n編寫程式碼–多邊形與多邊形 雖然這裡的寫法也還是沒有完全優化，其實你可以將normal_polygonA、B合併後在一起走訪，但我想範例這樣比較容易了解。\n// true:兩物體分離, false:兩物體碰撞 function SAT_Collision(polygonA, polygonB) { // 取得多邊形每個邊上的法向量，回傳陣列  var normal_polygonA = polygonA.getNorm(), normal_polygonB = polygonB.getNorm(); // 取得多邊形的頂點陣列，回傳陣列  var vertices_polygonA = polygonA.getVertices(), vertices_polygonB = polygonB.getVertices(); var isSeparated = false; // 透過迴圈走訪多邊形A的法向量，來檢查是否分離  for (var i = 0; i \u0026lt; normal_polygonA.length; i++) { var minMax_A = getMinMax(vertices_polygonA, normal_polygonA[i]); var minMax_B = getMinMax(vertices_polygonB, normal_polygonA[i]); isSeparated = (minMax_B.min \u0026gt; minMax_A.max || minMax_A.min \u0026gt; minMax_B.max); // 只要發現有一條分離線，就代表物體沒有發生碰撞  if (isSeparated) return true; } // 透過迴圈走訪多邊形B的法向量，來檢查是否分離  for (let i = 0; i \u0026lt; normal_polygonB.length; i++) { var minMax_A = getMinMax(vertices_polygonA, normal_polygonB[i]); var minMax_B = getMinMax(vertices_polygonB, normal_polygonB[i]); isSeparated = (minMax_B.min \u0026gt; minMax_A.max || minMax_A.min \u0026gt; minMax_B.max); if (isSeparated) return true; } // 如果所有法向量都檢查過後，沒有發現分離，代表兩物體碰撞  return false; } 由Code可以看到，只要物體間有分離，就可以跳出並回傳結果，不需要再去檢查B的法向量。\n要注意這邊的isSeparated在分離時為Ture、碰撞時為False，如果你要以碰撞作檢查的話記得加上NOT。\n使用範例:\nfunction update(dt) { polygonA.update(dt); polygonB.update(dt); var isCollided = !SAT_Collision(polygonA, polygonB); if(isCollided){ // ...發生碰撞後要做的事...  } } 測試結果:\n   \n原始碼在最後。\n編寫程式碼–多邊形與圓 已經完成範例，但還沒編寫文章\n假設今天是N多邊形與圓形，大致的做法就是，一樣取得多邊形的法向量做分離軸檢測，然後最後再多補上一條分離軸，為圓心到多邊形最近的頂點，這樣就能正確的判斷圓形。\nSAT的總結 關於SAT的優缺點:\n SAT的方法是些假設兩物體是分離的，並在檢查中只要成功找到正確的分離軸，就直接跳出，所以當物體都是分離狀態時，SAT的效率是非常高的。 只要物體之間有碰撞，SAT就必須檢查所有的法向量，來確保物體之間沒有分離線，越多的物體發生碰撞，效率也就越低。 因為SAT是採用所有法向量來作檢測，當多邊形的邊越多時，效率也會越來越低，但可以透過找出正負相反的法向量來減少檢查次數。 SAT雖然無法檢查凹多邊形，但是能透過將多個凸多邊形組合成凹多邊形的形狀，來作碰撞檢測。  如上圖中的賽車，雖然它的形狀是凹邊形，但能透果右邊的方式來做精密的碰撞檢測  SAT在運算時能夠取得碰撞物體間的最小穿透量(MTV, Minimum translation vector)，所以能夠處理物體間的碰撞回饋，並進一步地達成剛體動力學的模擬。  當我們希望物體不要發生穿透時，就會需要所謂的MTV，當物體穿透時，選一個最小的穿透量，將它平移回去   所以SAT碰撞在做過效能調整後，是很好的碰撞檢測演算法，靈活度也很高，是很多物理引擎會採用的檢測法之一。\n還有另一個凸邊形的高效演算法GJK以疊代地生成單形以對兩個凸集求閔可夫斯基和，有興趣可以研究看看。\n如果對碰撞方法有興趣的話可以參考這篇:\nBullet physics engin軟體工程師-Erwin Coumans : Collision Detection for Real-Time Simulation\n其他相關資源:\n SAT (Separating Axis Theorem) 2D Collision Detection 2D polygon-based collision detection and response Video Game Physics Tutorial  多物體的碰撞優化 當我們要檢查多個物體碰撞時，通常會直接對所有物體互相進行判斷，就像下面這段Code:\n基本枚舉法的Code:\n// shapes是指所有的物體陣列 function update(dt) { // ...更新物體狀態...  for (var i = 0; i \u0026lt; shapes.length; i++) { for (var j = 0; j \u0026lt; shapes.length; j++) { // 如果是同個物體就跳過  if (i == j) continue; var isCollided = !SAT_Collision(shapes[i], shapes[j]); if(isCollided){ // ...碰撞事件...  } } } } 用這種最直觀的方式檢查，時間複雜度會達到O(n!)，當場景複雜，需要檢測的物體變多後，用枚舉的方式檢測可能會導致遊戲延遲。\n其中最大的問題就是，當場景中有兩個距離非常遠的物體，遠到根本不可能發生碰撞，卻照樣對他們進行檢測，導致效能的浪費。\n簡單的介紹一個優化方法 – AABB Tree :  簡易AABB Tree \n建立ABT的方法跟建立二元樹的方法一樣，來看執行步驟:\n Step1. 把A加入樹中，作為根結點。 Step2. 把B加入樹中，判斷是否與根結點A有碰撞，如果有的話就在繼續比較子節點，如果都沒有與子節點有碰撞，就把B加入子節點後，如果與節點都沒有碰撞的話，就把A、B當作一個新區域，並生成A、B的父節點(橘色圈圈)。 Step3. 把C加入樹中，方法跟Step2一樣，最後得到上圖中的樹。  假如我要檢查A物體時，只需要檢查同在橘色區域的B物體即可。\nAABB Tree在建立時，就先把有機會碰撞的放在同一區，有了這樣的結構後，要判斷碰撞的效率就提高了，因為只需判斷與該物體同區域的物體即可，並不需要全部檢查，使得時間複雜度縮減到O(log n)。\n而其他多物體碰撞的演算法還有:\n四叉樹(Quad Trees)、八叉樹(octree)、二元分割樹(BSP tree)、kd樹、球體樹(sphere tree)、R樹(R tree)、碰撞投影、光線投影等等…，有興趣的可以在自己研究。\n動態物體間的碰撞檢測 這裡為大家提供一些解決的方向，我目前知道有這種解決方法，但礙於能力不足，只研究到觀念部分。\n在我們前面講的碰撞檢測方法都只適用在靜態，什麼意思呢?\n在遊戲中做的碰撞檢測其實是以離散時間來模擬，因此在每個瞬間，物體的位置和方向是靜止的，就像快照一樣，若物體的移動速度與其相對尺寸來說不是太快的話，這種方法是可行的，事實上在許多物理引擎中，都是使用這種方法。\n但對於較小且高速的移動物體，這種方法就會失效，想像現在有個很小的物體，他每次更新時的移動幅度大於碰撞體的尺寸，就會發生「穿隧」的問題。\n 如上圖所示，細小且快速的物體移動時，其路徑可能留下縫隙，導致碰撞失效。 \n解決方法\n掃描形狀(swept shape):\n對一個物體的位置、速率與加速度取線性穿插，得到一個時間段的物體快照，再透過掃描的形狀做檢測。\n 如上圖，中間的移動量就是兩次快照間的穿隧量，而球體的掃描體變成膠囊狀，三角形的掃描體變成三角柱。   若要掃描的物體正在旋轉，也能透過線性穿插來建立掃描形狀 \n形狀掃描對動態物體來說，是一個有效的檢測技術，能保證不錯過快照之間的碰撞。\n缺點是，若物體的行進路線為曲線甚至旋轉，僅透過線性穿插計算，其結果是不準確的，所以要再根據狀況使用更精準的技術。\n其實還有很多更好的解決方案，有興趣的可以在自己研究。\nSource Code 執行範例:\n我的SAT碰撞執行範例 : ver0.2.1-polygon-merge\nSource Code:\n 文章中的範例Source Code: https://github.com/md9830415/Collision-Detection-article 自製的向量函式庫 : https://github.com/md9830415/JS-Vector2D SAT碰撞檢測 Code: https://github.com/beadx6ggwp/Collision-SAT  額外應用:\n 最小位移量MTV Code: https://github.com/beadx6ggwp/Collision-MTV    結尾感想 那麼為什麼要對碰撞這麼刁鑽，就是為了能模擬物理效果，當碰撞的處理達到一定的程度後，就可以邁向下一個階段「剛體動力學」與「物理模擬」，讓電腦中的物體越來越接近現實，有趣吧。\n光是碰撞的處理就有這麼多複雜的技術問題，就可以了解高階遊戲開發工程師是多麼厲害的一群人了。\n為了做出更好的遊戲，還要很多東西要學，為了能有效的使用電腦資源，要學會作業系統架構、演算法、資料結構並精通程式語言，要能在螢幕中顯示各種效果、視角操控，還要學習電腦圖學、線性代數，為了處理物理模擬，還要學習古典物理、高等微積分，而這些東西到了三維空間後，又更加複雜，還有專案管理等等附加技能，加上遊戲工程師們也不斷的在進化，搞不好一輩子都學不完呢。\n 終於寫完了，這篇文中我嘗試用各種插圖來解釋一些觀念，不知不覺就打了這麼多，我Coding技巧很差，範例執行的效率可能沒有很好，但我想對這篇文想表達的內容影響不大。\n最後，感謝你的觀看，希望你在閱讀後能有些收穫。\n對這文章有任何問題，歡迎在下方留言提出意見，或是E-mail與我聯絡davidmd9830415@gmail.com。\n大概就是這樣了，掰掰。\n 首次發表時間 : 2017/8 高二升三暑假準備工科賽時製作\n參考資源:  Game Engine Architecture, Second Edition.pdf : here Video Game Physics Tutorial : here Collision Detection for Real-Time Simulation : here Collision Detection – contact generation and GPU acceleration : here Physics – Collision in 2 dimensions : here Collision Detection Using the Separating Axis Theorem : here SAT (Separating Axis Theorem) : here 2D Collision Detection : here 2D polygon-based collision detection and response : here Collision detection : here Collision resolution : here Introductory Guide to AABB Tree Collision Detection : here How to Create a Custom Physics Engine : here Vector maths – a primer for games programmers : here 平面上基本的線性變換：旋轉、鏡射、伸縮、推移 : here 二階方陣表示的線性變換 : here AABB包围盒算法,在2D碰撞检测中的实现 : here “等一下，我碰！”——常见的2D碰撞检测 : here Core HTML5 Canvas: Graphics, Animation, and Game Development  ","date":"2018-03-21T05:52:36+08:00","image":"https://davidhsu666.com/archives/gamecollisiondetection/img/SAT09.jpg","permalink":"https://davidhsu666.com/archives/gamecollisiondetection/","title":"遊戲中的碰撞檢測Collision Detection"},{"content":"\n簡介 參考這幾篇文章，並介紹線框繪製的問題點與解決方法:\n Single-Pass Wireframe Rendering, Siggraph 2006 Solid Wireframe, NVIDIA Whitepaper 2007 Two Methods for Antialiased Wireframe Drawing with Hidden Line Removal, SCCG \u0026lsquo;08  文章總結的線框渲染方式都非常簡單直觀，就是在Shader時，找出三角形內的動點P與邊界的最短距離d，當d \u0026lt; LineWidth時就代表P點屬於線框的部分，那就繪製線框的顏色，然後再透過smoothing function給LineWidth這個閥值做平滑，讓線段邊緣的顏色遞減，就這樣\n只是想嘗試敘述一開始所遇到的問題，並循序漸進的解決，到最後得出結論，來設想遇到問題該怎麼著手解決\n使用myMiniRender渲染的結果 :  (a)只使用const offset, (b)解決方法single pass method:邊距+平滑函數反鋸齒, (c)使用邊距+const offset, \n介紹 在建立了基本渲染流水線後，原本想要方便Debug，所以在pipeline外，將投影後的頂點座標連成線段三角形，來畫出基本線框方便觀察，而這大致就是gl.LINES的方式\nTextureShader shader; model = model_head; for (int i = 0; i \u0026lt; model-\u0026gt;nfaces(); i++) { Vec4f screen_coords[3];// 投影轉換後的座標  for (int j = 0; j \u0026lt; 3; j++) { screen_coords[j] = shader.vertex(i, j); } // 先忽略PixelShader，現在要的是線框，不是像素著色  // triangle(screen_coords, shader, device);  drawTriangleLine(screen_coords, black);// 類似gl.LINE的線段繪製 }  上面那段code所繪製的線框圖  myMiniRender線段繪製方形與模型線框 \n效果如上面兩張圖，但背面的線條會導致畫面很雜亂，為了正確顯示背部消除與物體遮擋，所以需要特別處理\n背部消除的線條，以往是分成兩次繪製(Two-pass)的方式，指同個畫面總共經過了兩次pipeline處理，讓物體與線框獨立繪製，並產生兩個深度緩衝(Z-buffer)，1.是繪製物體時的Zo(object)，2.是繪製線框時的Zw(wireframe)，通常繪製的順序是先繪製物體表面，然後在繪製線框時，比較Zw與Zo的深度，來判斷線框跟物體之間的前後遮擋\n問題 使用Two-pass這種方法繪製背部消除的線段時，會有幾個限制:\n 無法更改線條寬度、插值線段顏色等樣式處理 無法進行反鋸齒的處理，因為反鋸齒會需要透過流水線處理Blending等操作 物體與線段會使用一樣的頂點，也就代表共用一樣的深度，導致線框深度跟物體深度Z-buffer判斷遮擋的時候，深度一樣，不知道是物體在前，還是線段在前，導致Z-fighting   細節補充 :\n第一個pass渲染物體並產生Zo，而第二個pass詳細步驟是: 1.將線段頂點處理投影變換(MVP)後得到線段頂點的z-buffer, Zw，2.在光柵化線段像素P時，將P點的線段Zw與物體Zo的深度進行比較if(Zw(P) \u0026lt;Zo(P)) draw(P); //如果Zw(p)線框的點比較靠前，沒被遮擋就繪製，以此來繪製正確的遮擋線段。\n但這時物體與線段的pass都用一樣的頂點，可能會導致Z-fighting(深度z值一樣不曉得誰前誰後)或不正確的遮擋，所以需要透過深度偏移(depth bias offset)，在比較線框與物體的深度時，將原本物體的深度往後面一點的位置，才能正確讓線框繪製在物體前面。\n雖然繪製出的效果不錯，不過z-buffer的值是透過Perspective的非線性轉換得來，還有精度問題，所以在某些地方可能因為這一點點的前後差距導致一些本該被遮擋的區域未被遮擋，所以在某些時候會有問題\n 如圖(a)中的紅色的線段能正確被遮擋，且因為有深度偏移，讓線段頂點在物體的前面，所以第一次pass繪製物體產生Zo後，第二次pass在繪製線段時，只要比較線段中P點深度有沒有比Zo更近即可判斷是否繪製，以此達到線段遮擋與背部消除的效果，圖(b)引用Line Drawings from 3D Models, p18\n (a)物體的Z-buffer, Zo,與線段遮擋示意圖  (b)使用Laplacian of Gaussian filter在two-pass時處理物體輪廓 \n而這篇文章，希望透過循序漸進的方式，介紹可以在一個pass內繪製物體與線框的方法，僅透過Shader繪製時傳入的重心座標與頂點，即可在三角形邊緣繪製不同的圖案，而且因為是single-pass，相對來說效能更好，使用上也簡單好用\n這方法的缺點大概就是框線繪製在三角形內部，所以會使物體輪廓看起來更薄一些，也因為只在內部繪製，所以只有內側有反鋸齒效果\n解決方法與原理 必要知識 : 重心座標的推導與使用 Barycentric Coordinates、動畫圖解 Rasterizer Algorithm Explanation\n如果要在single-pass下完成的話，勢必要在「Shader繪製物體的時候一起畫出線段」，而在光柵化三角形(Rasterization)的時候，會有一個動點P去走訪三角形的所有像素區域，並給Shader傳入P點的重心座標\n單純使用重心座標 const offset 前面提到過，重心座標(bar)alpha、beta、gamma就是頂點A,B,C對面那塊區域的面積比，也就是說「當某一塊面積比為0時，就代表P點在三角形的邊上」\n線上操作範例 : 可拖動重心座標在三角形的邊界上移動，去觀察重心座標的值\n   \n如左圖，當重心座標在藍色線上時，beta比的面積為0，代表這個點在邊上，但光柵化時的像素渲染是一格一格的，很多時候P根本不可能剛好在邊界上\n如右圖，尤其是遠處的小片三角形，所佔有的像素區域非常少，整面三角形符合offset範圍的P點只有五個，那就會導致遠處物體看起來只剩下幾個點而已\n如圖中的綠點，要是只在邊上才繪製的話，線會斷斷續續的，而const offset這個方法，就是透過offset來修正這段誤差，只要任一個重心座標(面積比)alpha, beta, gamma \u0026lt;= offset，就認定這個P點在三角形的邊界上，繪製線段顏色，\nstruct LineShader : public IShader { // Vertex Shader: 處理座標投影轉換  virtual Vec4f vertex(int iface, int nthvert) ... // Pixel Shader: 處理P點的像素顏色, Vec3f bar為重心座標alpha, beta, gamma  virtual bool fragment(Vec3f bar, UI32\u0026amp; color) { float offset = 0.01; //容許的誤差範圍  if (bar[0] \u0026lt;= offset || bar[1] \u0026lt;= offset || bar[2] \u0026lt;= offset) color = 0x000000; // 黑色線框  else color = 0xFFFFFF; // 物體原本的顏色,這裡用白色代替  return false; } }; 上面這段Shader code會執行出這個結果:  (a): offset為0, 只有alpha,beta,gamma任一個為0時繪製, 很多線段根本沒辦法顯示, (b) offset為0.01, (c): offset為0.02 \n可以看到確實有線框了，但有些區域透過offset還是無法修正這些誤差，所以就會導致邊框不連續，而這繪製方法就是封面圖的(a)\n而且這種繪製法有個很明顯的缺點，就是線段寬度不一致，透過面積比來判斷是否在邊上，很容易被邊長的比例所影響，導致時粗時細(b)，有些線段甚至沒有繪製\n最短邊距法 shortest distance to the edge 這稱呼只是單純直翻，這還只是一個小撇步，應該沒有特定的名字\n (a)面積區域   (b)Solid Wireframe, NVIDIA Whitepaper, p10 \n為解決剛剛const offset厚度不一致的問題，衍伸的想法就是先找出P點離邊界最近的「像素距離d」是多少(表示作用的區域是Screen Space)，再透過一個width當作閥值，當d \u0026lt; width的時候才繪製線條，這樣就可以確保邊界繪製的寬度為width\n而找出d1, d2, d3的方法也很容易，步驟是:\n 邊向量外積得到三角形面積，$Area = \\bigtriangleup ABC = \\frac{1}{2}(\\overrightarrow{AB} \\times \\overrightarrow{AC})$ 重心座標就是面積比，得出$\\bigtriangleup A = Area \\times \\alpha,~~ \\bigtriangleup B = Area \\times \\beta ,~~ \\bigtriangleup C = Area \\times \\gamma $ 有了三塊區域的面積後就能直接根據面積公式$h= 2(\\frac{Area}{L}) $, 得出d1, d2, d3 再取最小值即可得到d = min[d1, d2, d3]  有了d之後就能對這個最短距離進行判斷，如果小於寬度就繪製線段顏色，如圖(b)\nstruct WireframeShader : public IShader { Vec2f screen_coords[3]; Vec3f wire_color = Vec3f(0, 0, 0); // 黑色線框  Vec3f fill_color = Vec3f(1, 1, 1); // 物體顏色, 這裡先用白色代替  float width = 0.5; // 線框寬度  // Vertex Shader  virtual Vec4f vertex(int iface, int nthvert) { // ...處理座標轉換省略  // 紀錄這片三角形投影後的三個頂點,  // 作用的地方是光柵時的螢幕座標系, Clip Space /w-\u0026gt;NDC-\u0026gt;Screen Space  screen_coords[nthvert] = proj\u0026lt;2\u0026gt;(pos / pos[3]); return pos; } // Pixel Shader: 最短邊距法線段繪製  virtual bool fragment(Vec3f bar, UI32\u0026amp; color) { float d = getMinDistToEdge(bar); if (d \u0026lt; width) c = wire_color; else c = fill_color; color = rgb2hex(c[0] * 255, c[1] * 255, c[2] * 255);// 0~1轉換成0~255  return false; } float getMinDistToEdge(Vec3f bar) { float dist[3]; auto getLength = [\u0026amp;](Vec2f\u0026amp; v) {return std::sqrt(v.x * v.x + v.y * v.y); }; // 透過三個頂點與重心座標回推掃描線p點，proj\u0026lt;2\u0026gt;:將Vec3捨棄z值轉換為Vec2  // P = A*alpha + B*beta + C*gamma  Vec2f p = proj\u0026lt;2\u0026gt;( screen_coords[0] * bar[0] + screen_coords[1] * bar[1] + screen_coords[2] * bar[2]); Vec2f v0 = screen_coords[2] - screen_coords[1]; Vec2f v1 = screen_coords[2] - screen_coords[0]; Vec2f v2 = screen_coords[1] - screen_coords[0]; // v1,v2外積取得三角形面積，原本要在乘上的1/2，不過後續的運算會消掉  float area = abs(v1.x * v2.y - v1.y * v2.x); // area*alpha:因為重心座標即為為a,b,c三區域佔總體的面積比值  // 可以直接將整體面積(Area)乘上a,b,c重心座標來取得各塊區域面積  // 再透與三塊面積取高，得出p點與各邊界的距離d為  dist[0] = area * bar[0] / getLength(v0); dist[1] = area * bar[1] / getLength(v1); dist[2] = area * bar[2] / getLength(v2); return min(dist[0], min(dist[1], dist[2])); } }; 這段Shader code會執行出這樣的結果:  (a) 最短邊距法, width=0.5   (b) 左:width = 10px, 右:width = 2px \n圖(a)這張就是封面圖的(c)部分，稍微換個顏色，可以明顯看到，這樣的線框已經足夠使用了，圖(b)也能任意控制線框寬度與著色樣式)，但是線框看起來還是有一點粗糙，所以接著最後一步處理，反鋸齒\n反鋸齒處理Antialiased Wireframe Drawing 圖片引用自Solid Wireframe, NVIDIA Whitepaper, p10, p11  (a) smoothing function  (b) 作用原理的示意圖 \n接續剛剛的最短邊距法，可透過圖(a)的這個平滑函數，套用在邊界處，讓邊界外的顏色遞減，並進行Alpha blending將線框與物體按照衰減度混色，即可得到反鋸齒的效果\nstruct WireframeShader : public IShader { Vec2f screen_coords[3]; Vec3f wire_color = Vec3f(0, 0, 0); // 黑色線框  Vec3f fill_color = Vec3f(1, 1, 1); // 物體顏色, 這裡先用白色代替  float width = 2; // 線框寬度  // Vertex Shader 同上  virtual Vec4f vertex(int iface, int nthvert)... // Pixel Shader: 反鋸齒的最短邊距法繪製  virtual bool fragment(Vec3f bar, UI32\u0026amp; color) { float d = getMinDistToEdge(bar); // 對線框寬度的+/-1邊界進行平滑  // 帶入最短距離d得出width邊界所對應的線框顏色的強度 I  // 如果d\u0026lt;=width-1，那I就一定是1  float I = smoothstep(width - 1, width + 1, d); // 進行Alpha blending，將線框與物體顏色照比例混合  Vec3f c = wire_color * I + fill_color * (1.0 - I); color = rgb2hex(c[0] * 255, c[1] * 255, c[2] * 255); return false; } float smoothstep(float edge0, float edge1, float x) { // Scale, bias and saturate x to 0..2 range  x = clamp((x - edge0) / (edge1 - edge0), 0.0, 2.0); return exp2(-2 * x * x); } float clamp(double d, double min, double max) { const double t = d \u0026lt; min ? min : d; return t \u0026gt; max ? max : t; } float getMinDistToEdge(Vec3f bar)... }; 執行這段Shader code後，最終得到封面圖中間(b)的漂亮線框  (a) width = 2, 繪製的反鋸齒線框 \n應用與討論 前面講完原理後，簡單的介紹一些衍伸用法\n虛線樣式 因為能求出在最短邊距，那麼就可以對物體邊界位置動態給定閥值，搭配其他搭配其他函數做出類似虛線、圖案，或透過Z值來繪製背面透明等線框效果\n完整虛線樣式的效果可以參考這個漂亮的線上範例\n 閥值函數圖, 參考[4].  繪製效果 \n外側反鋸齒 而文章一開始的問題章節有提到過，這種方法繪製的反鋸齒只有內側，如圖(a)\n (a) 放大線框可以看到，只有內側有反鋸齒的效果   (b) 將線段向內偏移，騰出外側反鋸齒的空間 \n有一種解決方法，就是讓線框往三角形內部偏移一點，這樣雖然會犧牲一點物體的輪廓大小，但應該是簡單有效的處理方式，只不過也不是正確的方式，因為不是跟背景色做Alpha blending\n而Two Methods for Antialiased Wireframe Drawing with Hidden Line Removal的文章中，有提出一種方法叫做ID Buffer，雖然會犧牲一點效能，但能有效的解決外側反鋸齒的問題，有興趣可以看看\n優缺點 這個Single pass render方法，有幾個優缺點\n 能背部消除，且繪製的深度準確 可透過插值、函數等方式更改線段樣式，如彩色、虛線等 只需要一次pass，速度較快  缺點目前覺得就是只有內側能反鋸齒，在渲染大片三角形的模型中會有比較大的影響\n而Solid Wireframe, NVIDIA Whitepaper中有提到說在頂點與觀察點非常接近，或是裁切處理的情況，會有一些問題，需要做特別的處理\n結語 線框繪製也廣泛的應用在特殊風格渲染，如卡通著色、繪本風格等等的，這類著色風格被稱為Non-photorealistic Rendering\n 引用,Line Drawings from 3D Models   引用,卡通外描邊深入研究與Unity新管線功能使用分享 \n衍伸閱讀，參考資料中的這篇Line Drawings from 3D Models，裡面提供了非常多種線框繪製的方法，原本繪製線框只是為了Debug，但查了很多資料後才發現，線框的繪製也是一門學問\n大致就是這樣，嘗試敘述並解決一個問題的文章，希望有解釋的淺顯易懂\nGithub專案: https://github.com/beadx6ggwp/RenderLearningPlan\n文章中渲染結果都使用這個版本繪製: 12.2 Lesson 6 Shaders(wireframe render \u0026amp; vertax-obj)\nReference  Solid Wireframe, NVIDIA Whitepaper 2007 Line Drawings from 3D Models, Foundations and Trends in Computer Graphics and Vision 2019 Single-Pass Wireframe Rendering, Siggraph 2006 Two Methods for Antialiased Wireframe Drawing with Hidden Line Removal, SCCG \u0026lsquo;08 webgl-wireframes, github glsl-solid-wireframe, github WebGL 单通道wireframe渲染, 知乎 Wireframe-的实现, 知乎 Wireframes with barycentric coordinates, blog Flat and Wireframe Shading, blog Wireframe shader implementation, Cinder Forums [Real-Time Rendering.3rd, Book] 卡通外描邊深入研究與Unity新管線功能使用分享  ","date":"2021-07-03T23:39:36+08:00","image":"https://davidhsu666.com/archives/wireframe-display/img/ps/teapot_5.1.png","permalink":"https://davidhsu666.com/archives/wireframe-display/","title":"Shader重心座標的線框繪製"},{"content":"定義  \n平面三角形T有A、B、C頂點，而內部的任一點P，都可以透過$\\overrightarrow{AB}$與$\\overrightarrow{AC}$的線性組合來表示，所以P點表示法如下:\n$$ \\overrightarrow{AP}=u\\overrightarrow{AB}+v\\overrightarrow{AC} $$\n將它分解整理後: $$ P-A=u(B-A)+v(C-A) $$\n最終得到: $$ P(x,y) = (1-u-v)A + uB + vC~,~~0\\leq u,v\\leq 1$$\n如果將A、B、C的三個係數換一下，就變成:\n$$ P(x,y)= \\alpha A + \\beta B +\\gamma C~,~~\\alpha+\\beta+\\gamma=1 $$\n而這就是重心座標的表示法，透過 $[\\alpha,\\beta,\\gamma]$ 這三個介於[0,1]之間的係數，來決定P在三角形內部的相對位置\n實際範例: Barycentric coordinates of a point\n首先第一個問題就是，有了三角形ABC與內部的P點，要怎麼求出對應的係數?\n推導方式 1. 外積 將原式改寫，可以把P點看成是起點為A，透過$\\overrightarrow{AB},\\overrightarrow{AC}$為基底的座標為$(u,v)$: $$ P = A + u\\overrightarrow{AB}+v\\overrightarrow{AC} $$ 找到滿足此條件的$u,v$ $$ u\\overrightarrow{AB}+v\\overrightarrow{AC}+\\overrightarrow{PA} = 0 $$ 平面三角形的座標拆開成$(x,y)$分量\n$$ \\begin{cases} u\\overrightarrow{AB}.{x} + v\\overrightarrow{AC}.{x} + \\overrightarrow{PA}.{x} = 0 \\\\ u\\overrightarrow{AB}.{y} + v\\overrightarrow{AC}.{y} + \\overrightarrow{PA}.{y} = 0 \\end{cases} $$\n以矩陣表示: $$ \\begin{cases} \\begin{bmatrix}u \u0026amp; v \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} \\overrightarrow{AB}.{x} \\\\ \\overrightarrow{AC}.{x} \\\\ \\overrightarrow{PA}.{x} \\end{bmatrix}=0 \\\\ \\\\ \\begin{bmatrix}u \u0026amp; v \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} \\overrightarrow{AB}.{y} \\\\ \\overrightarrow{AC}.{y} \\\\ \\overrightarrow{PA}.{y} \\end{bmatrix}=0 \\end{cases} $$\n可以發現兩條式子的點積都為0，表示$[u,v,1]$這個向量，同時垂直於$x$分量與$y$分量，這就代表$[u,v,1]$剛剛好就是x分量與y分量的外積(Cross)\n另變數 uv 為$[u,v,c]$ = $(\\overrightarrow{AB}.{x} , \\overrightarrow{AC}.{x} , \\overrightarrow{PA}.{x}) \\times (\\overrightarrow{AB}.{y} , \\overrightarrow{AC}.{y} , \\overrightarrow{PA}.{y})$ 的結果\n但這裡要注意的是，uv得到的外積結果，僅僅是方向正確，確實垂直於x與y分量的向量，但大小卻不一定正確，不過 $c$ 的值已經知道是1了，所以只要讓uv的值要再進行縮放，讓 $c = 1$ 就是正確的 $uv$\n將$[u,v,c]$帶回: $$ u\\overrightarrow{AB}+v\\overrightarrow{AC}+c\\overrightarrow{PA} = 0 $$\n$c$ 的值應該要為1，同除以 $c$ 得到: $$ \\frac{u}{c}\\overrightarrow{AB}+\\frac{v}{c}\\overrightarrow{AC}+\\overrightarrow{PA} = 0 $$ 展開將P拿出來，最終得到完整式子: $$ P = (1-\\frac{u}{c}-\\frac{v}{c})A + \\frac{u}{c}B + \\frac{v}{c}C~,~~c\\neq 0 $$\n也就是: $$ P= \\alpha A + \\beta B +\\gamma C~,~~\\alpha+\\beta+\\gamma=1 $$ 其中: $$ \\begin{cases} \u0026amp; \\alpha=1-\\frac{u}{c}-\\frac{v}{c} \\\\ \u0026amp; \\beta= \\frac{u}{c} \\\\ \u0026amp; \\gamma= \\frac{v}{c} \\end{cases} $$\n程式碼:\n// 透過外積法計算向量座標 Vec3f barycentric(Vec2f A, Vec2f B, Vec2f C, Vec2f P) { // Vec3f [x,y,z] = [u,v,c]  Vec3f vec_x(B.x - A.x, C.x - A.x, A.x - P.x); // vAB.x,vAC.x,vPA.x  Vec3f vec_y(B.y - A.y, C.y - A.y, A.y - P.y); // vAB.y,vAC.y,vPA.y  Vec3f uv = cross(vec_x, vec_y);\t// 不得除以0，做個檢查，因為浮點數可能會有誤差，所以給定一個範圍  if (std::abs(uv[2]) \u0026gt; 1e-2){ float alpha = 1.f - (uv.x + uv.y) / uv.z; float beta = uv.y / uv.z; float gamma = uv.x / uv.z; return Vec3f(alpha, beta, gamma); } // uv.z為0的狀況為異常，傳回不符合定義的值，讓rasterizator捨棄這個點  return Vec3f(-1, 1, 1); //通常不會發生 } \n推導方式 2. 面積比  GAMES101_Lecture_09 \n$\\alpha, \\beta ,\\gamma$ 為A,B,C頂點對邊的面積比，詳細證明待補，面積比有兩種大致的推導方法:\n 直接行列式求面積去算$\\alpha$=Area(BPC)/AREA(ABC) 參考 找出AC邊的法向量N，將AP投影到N上，即可得到AC到P點的高，而底邊就是|AC|，將高乘以底邊就是Area(APC)的面積，剩下就一樣求出面積比  1.的方法很直觀不用推了，簡單推導2.的方法:    AP投影在Nac的高，乘上底邊AC來找出B區的面積  Right Normal的取得參考#3-知識補充1向量，而計算完的參數直接就是$[\\alpha,\\beta,\\gamma]$了，不用像外積法要多一步\n$$ P= \\alpha A + \\beta B +\\gamma C~,~~\\alpha+\\beta+\\gamma=1 $$\n// 透過面積計算重心座標 Vec3f barycentric(Vec2f A, Vec2f B, Vec2f C, Vec2f P) { auto ab = B - A; auto ac = C - A; auto ap = p - A; Vec2f nac(A.y - C.y, - A.x + C.x); Vec2f nab(A.y - B.y, - A.x + B.x); float beta = (ap * nac) / (ab * nac); // operator* is dot  float gamma = (ap * nab) / (ac * nab); float alpha = 1.f - beta - gamma; return Vec3f(alpha, beta, gamma); } \n基本使用 基本轉換:\n  已知三頂點A,B,C位置與絕對位置P點，要如何得出相對位置的比例參數 $[\\alpha,\\beta,\\gamma]$ ?\n直接帶入前面完成的bary函式bary(A,B,C,P)，得到計算後傳回的 $[\\alpha,\\beta,\\gamma]$\n  已知A,B,C頂點與相對位置參數 $[\\alpha,\\beta,\\gamma]$ 或是 $[u,v]$，如何得到絕對位置P點?\n直接將參數與頂點代入定義即可:\n$ P= \\alpha A + \\beta B +\\gamma C $ $ P= (1-u-v)A + uB + vC $\n  應用方式 紋理貼圖:\n \n如上圖，希望能將左邊藍色的貼圖，映射到右邊的紅色模型上，這過程稱為紋理貼圖或是貼皮，而此時會有幾個問題\n 紅色三角形已經過座標變換，掃描線準備上色時會有一個動點P，如何知道三角形中所有P點對應的貼圖顏色? 兩片三角形已經大不相同，要如何在不影響圖形比例的情況將其著色?  掃描線的動畫圖解: Rasterizer Algorithm Explanation\n大略步驟:\n 透過Barycentric(V1, V3, V4, P)，得到P點在紅色三角形的相對位置(u, v) 帶入貼圖三角形T中 $P'= (1-u-v)T_{1} + u~T_{2} + v~T_{4}$ 取得$P'$點座標，也就能取得貼圖於P(x,y)的顏色 最後就能取得紅色P點對應的貼圖顏色，如此反覆將P隨著掃描線計算，即可取得整片三角形的貼圖對應  重複此過程渲染兩片三角形後，就能將骰子點數6的這一面印出\n結論 暫無，之後再補\n Reference  Fundamentals of Computer Graphics 4th scratchapixel, Rasterization: a Practical Implementation Tiny Renderer:Triangle rasterization and back face culling Barycentric Coordinates GAMES101-现代计算机图形学入门-闫令琪 计算机图形学三(补充)：重心坐标(barycentric coordinates)详解及其作用 二圈妹:三角形重心坐标  ","date":"2021-07-01T21:00:47+08:00","image":"https://davidhsu666.com/archives/barycentric-coordinates/img/bary5.png","permalink":"https://davidhsu666.com/archives/barycentric-coordinates/","title":"重心座標的推導與使用 Barycentric Coordinates"},{"content":"Win32 參考 : MSDN Get Started with Win32 and C++\n建立entry point, WinMain() // int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR pCmdLine, int nCmdShow) // wWinMain為UniCode模式，WinMain為Ansi模式  int CALLBACK WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow){ // ...  return 0; } #define CALLBACK __stdcall: 簡單來說__stdcall就是專門用來call WinAPI的，詳細還有待研究\n參數:\nhInstance : windows為應用程式生成的追蹤資料，h代表handle(處理程序)\nhPrevInstance : 追蹤建立此視窗的前一個程式，但現在基本無用\nlpCmdLine : 相當於int main(int argc, char** argv)的執行時可傳入的參數列 e.g. main.exe -t -d\nnCmdShow : 為一整數，在執行時傳入來控制視窗的樣式 e.g. SW_MAXIMIZE (3)、SW_MINIMIZE (6)、SW_SHOWMINNOACTIVE (7 啟動時最小化) 等等\n 向系統註冊此視窗程式 WNDCLASS WNDCLASSA structure (winuser.h)、 Window Class Styles、 RegisterClass\ntypedef struct tagWNDCLASSW { UINT style; WNDPROC lpfnWndProc; int cbClsExtra; int cbWndExtra; HINSTANCE hInstance; HICON hIcon; HCURSOR hCursor; HBRUSH hbrBackground; LPCWSTR lpszMenuName; LPCWSTR lpszClassName; } WNDCLASSW style : 不是造型的那種style，而是視窗行為模式的設定，像是CS_HREDRAW | CS_VREDRAW\nlpfnWndProc : Window事件處理的CallBack，funcPointer\ncbClsExtra、cbWndExtra : 視窗類分配的額外字節數。在大多數情況下，此成員為0。\nhInstance : 通常直接將WinMain的hinst傳過來即可，因為同一個視窗程式\nlpszMenuName : Menu ID，不需要的話NULL即可\n所以基本上只需要幾個關鍵參數:\nWCHAR cls_Name[] = L\u0026#34;Win32 Class\u0026#34;; WNDCLASS wc = { }; wc.lpfnWndProc = WindowProc; wc.lpszClassName = cls_Name; wc.hInstance = hInstance; // 並在最後向上層系統註冊此視窗類別，為什麼要註冊還有待研究 RegisterClass(\u0026amp;wc); 建立與顯示視窗 CreateWindow MSDN CreateWindowExA function、 window style values\nvoid CreateWindowA( lpClassName, //類別名稱，要和剛剛一致  lpWindowName, //標題文字  dwStyle, //視窗外觀樣式 window style values  x, //相對於parent的x座標  y, //相對於parent的y座標  nWidth, //視窗寬度  nHeight, //視窗高度  hWndParent, //parent window，沒的話NULL即可  hMenu, //menu，沒的話NULL即可  hInstance, //當前程式的Hander  lpParam //附加資料，沒的話NULL即可 ); returnType HWND 使用方式: 基本上照著參數給予資料，就會執行建立視窗這個動作，並返回HWND(此視窗的handle)\nHWND hwnd = CreateWindow( cls_Name, //類別名稱，註冊與建立要是同個視窗類別  L\u0026#34;Win32 test\u0026#34;, //標題文字  WS_OVERLAPPEDWINDOW, //視窗外觀樣式  100 //相對於parent的x座標  200, //相對於parent的y座標  400, //視窗寬度  300, //視窗高度  NULL, //parent window，沒的話NULL即可  NULL, //menu  hInstance, //當前程式的追蹤  NULL); //附加資料  if (hwnd == NULL) //判斷是否成功Create  return 0; 訊息監聽(Event Handler) WinProc  訊息流程 \n整個視窗程式不是單純建立而已，Windows背後會處裡很多事情，像是基本滑鼠鍵盤的IO、WM_CREATE建立時發起的事件、WM_DESTROY(在關閉視窗後釋放資源)、WM_Paint視窗繪製事件等等，所以需要透過監聽的方式持續檢查收到甚麼消息\n如果只有前面那幾段，程式會是開起來後馬上關掉，其實不是執行失敗，而是執行後馬上就結束了，像是Console中可以透過system(\u0026ldquo;pause\u0026rdquo;)或是getchar()來卡著程式直到使用者輸入，但視窗程式用戶除了鍵盤以外還有滑鼠等各種操作，如移動視窗、縮放視窗、縮小視窗等等，用getchar()會導致程式卡在這裡無法進行其他操作\n所以windows視窗程式透過無限迴圈讓程式一直不結束，只是這樣一樣甚麼事情都做不了，也無法關閉程式，這時就有了事件監聽這種設計，在必要的時候傳指令給程式，讓程式做出對應的功能，像是按下X的時候，系統會送出QUIT的事件，讓程式知道現在要關閉程式釋放資源\n而有事件監聽後，就要有地方來儲存累積起來的事件，讓程式逐一處理，而這就是訊息序列MsgQueue\ntypedef struct tagMSG { HWND hwnd; UINT message; WPARAM wParam; LPARAM lParam; DWORD time; POINT pt; } MSG, *PMSG, *LPMSG; 完整範例Code 執行方法，VS建立empte winodws專案，加入CPP檔案並把這段貼上即可\n#include \u0026lt;Windows.h\u0026gt; //LRESULT CALLBACK WindowProc(_In_ HWND hwnd, _In_ UINT uMsg, _In_ WPARAM wParam, _In_ LPARAM lParam); LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);//MSDN  // entry point //_In_opt_ SAL annotations(向編譯器詳細規範參數型態) int CALLBACK WinMain( _In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ int nCmdShow) { WCHAR cls_Name[] = L\u0026#34;Win32 Class\u0026#34;; /* 執行時此處要注意 RegisterClass(): MSDN:You must fill the structure with the appropriate class attributes before passing it to the function. 表示WNDCLASS需要完全初始化才行，如果沒有全部初始化，會導致變數無法正確的分配空間，導致註冊失敗 要不就是所有變數手動指定預設資料，但有點麻煩，所以需要 WNDCLASS wc = { sizeof(WNDCLASS) }; 再簡化就是WNDCLASS wc = { }; 補充: typedef struct rectStruct { int x; int y; int width; int height; } RECT 初始化所有資料: RECT rect = { 0, 0, 20, 30 }; 初始化所有為預設值(此為int所以為0) RECT rect = { }; */ WNDCLASS wc = { }; wc.hbrBackground = (HBRUSH)COLOR_WINDOW; wc.lpfnWndProc = WindowProc; wc.lpszClassName = cls_Name; wc.hInstance = hInstance; // 向上層註冊  RegisterClass(\u0026amp;wc); HWND hwnd = CreateWindow( cls_Name, //類別名稱，要和剛剛一致  L\u0026#34;Win32 test\u0026#34;, //標題文字  WS_OVERLAPPEDWINDOW, //視窗外觀樣式  100, //相對於parent的x座標  200, //相對於parent的y座標  800, //視窗寬度  600, //視窗高度  NULL, //parent window，沒的話NULL即可  NULL, //menu  hInstance, //當前程式的追蹤  NULL); //附加資料  if (hwnd == NULL) //判斷是否成功Create  return 0; // 顯示視窗  ShowWindow(hwnd, SW_SHOW); // 更新視窗，通常可有可無，因為只要視窗開著，WM_PAINT就會持續調用並更新視窗  //UpdateWindow(hwnd);  // 事件訊息loop  MSG msg; while (GetMessage(\u0026amp;msg, NULL, 0, 0)) { TranslateMessage(\u0026amp;msg); DispatchMessage(\u0026amp;msg); } return 0; } // callback事件處裡 function pointer LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) { switch (uMsg) { case WM_DESTROY: { PostQuitMessage(0); return 0; } } return DefWindowProc(hwnd, uMsg, wParam, lParam); } ","date":"2020-12-11T05:01:26+08:00","image":"https://davidhsu666.com/archives/win32note01/img/1602103707812.jpg","permalink":"https://davidhsu666.com/archives/win32note01/","title":"[Win32筆記] 建立視窗 #1"},{"content":"從零開始的基礎RPG框架 Sourcecode : 運行SourceCode時將此目錄丟到Apache中即可\n遊戲Demo連結 操作方式: 上下左右、空白鍵衝刺、 Z 攻擊、X 遠程、T 開啟Debug、WASD移動視角、R 重製視角\n ver01(game) : 可以讀取地圖的第一版 基礎展示(game0) : 用簡易的基礎地圖展示所有功能 上下坡事件觸發器(game2) :  透過觸發器更改人物所在圖層，正確判斷上下坡的碰撞  完整的場景(gameshow1) :  右邊兩個圓形為加速事件觸發器，碰到即可變更速度  多邊形碰撞場景(gameshow2) :  滑鼠拖曳後按左鍵發射小球，來觀看多邊形碰撞回饋   目前進度  攝影機 動態碰撞盒 事件觸發器 自訂地圖存取 Debug(圖層、碰撞層顯示)  攝影機、Debug  加入Debug功能方便測試 只顯示視線範圍內的物件 渲染物件的動態圖層顯示 可隨意設定攝影機的追蹤範圍與目標，例如視角綁定在小鳥身上   WASD控制攝影機   透過Z-index畫家排序來處理多圖層 \n碰撞盒:多邊形碰撞與回饋 http://davidhsu666.com/archives/gamecollisiondetection/\n透過分離軸定理，解決普通AABB碰撞檢測無法處裡的多邊形與圓形\n建立自製碰撞函示庫，並透過最小穿透量來處理物體間的分離，將碰撞盒整合至物體中並加以應用\n   \n動態碰撞盒、敵人移動、事件觸發器 -透過動態碰撞盒處理揮砍的動作\n-加入狀態切換管理，攻擊開始-\u0026gt;攻擊中-\u0026gt;攻擊結束\n 透過事件觸發器處理各式地圖事件 像是地圖上下坡，需要切換碰撞層，與NPC對話區域的觸發器，或是走斜坡時會被減速等等   發射劍氣   事件觸發器-加速 \n地圖編輯與讀取 透過json檔案生成對應的地圖物件，如動畫、碰撞、物件等\n依照編輯時的圖層，建立對應的顯示順序\n而每個Group相隔10的Z-index，圖中Group2、Group4分別有橋下與橋上的碰撞層，所以只要更改人物的Z-index即可實現上下區域的碰撞切換\n並支援自訂多邊形，圖中左下角的噴水池為自訂多邊形所包成的碰撞體，基礎展示(game0)中的石頭也是\n 地圖的編輯 \n大致運行方式 所有物體皆繼承自Entity :\nEntity: { name: \u0026#34;monster\u0026#34; // 此Entity的名稱或類別  pos: { x: 0, y: 0 }, vel: { x: 0, y: 0 }, acc: { x: 0, y: 0 }, zindex: 20, collider: { // 碰撞盒範圍，不規則多邊形則指定相對位置頂點  x: -15, y: -15, w: 30, h: 30 }, bounceToMap: false, // 是否與地圖發生向量鏡射的反彈回饋  collisionToMap: true, // 是否與地圖發生碰撞  world: Worldmap, // 所在的地圖  animation: { // 圖片的設置  frameWidth: 44, frameHeight: 40, renderScale: 1 / 2, imgName: \u0026#39;coin\u0026#39;, speed: 15, action: { // 設定個動作的循環  \u0026#39;default\u0026#39;: \u0026#39;0-9\u0026#39;, // 可連續設置也可跳號指定  \u0026#39;atk\u0026#39;:\u0026#39;11,12,14,19\u0026#39;, \u0026#39;imgMode\u0026#39;,\u0026#39;25\u0026#39; // 靜態圖片模式  } }, survivalMode : false, // 是否消失  survivalTime : -1, // 設定存在時間  hitActionData :{ // 事件觸發器: 設定此Endity在更新時要和誰互動的事件  target: [...], // 設定那些物體會觸發  action: (ent1, ent2) { // ent1為自己、ent2為其他entity  // 設定兩物體接觸後的處理，如碰撞分離、更改速度等等的事件觸發器  } } } 事件觸發器的使用，以地圖中的Tile與玩家/怪物的碰撞為例:\nTileEntity = { name: \u0026#39;layerObj\u0026#39;, pos: { x: 0, y: 0 }, // 設定為每塊Tile所在的位置  collisionToMap: false, hitActionData: { parent: this, // 觸發器的本體是誰  target: [\u0026#39;player\u0026#39;,\u0026#39;enemy1\u0026#39;], // 設定和player與enemy兩種Entity反應  // 對target中的物體執行對應動作  action: function (ent1, ent2) { // 取得自己與其他Entity的碰撞盒  let collider1 = ent1.getCollisionBox(); let collider2 = ent2.getCollisionBox(); // 碰撞檢測  if (!box2box(collider1.getBoundingBox(), collider2.getBoundingBox())) return; // 處理碰撞後的推擠判斷與向量鏡射  let mtv = collider1.collideWith(collider2); if (mtv.axis) { let v = separate(collider1, collider2, mtv) ent2.pos.add(v); mtvBounce(ent2, mtv) } } }, drawBase: true } 當所有物體，不管是玩家、敵人、地圖Tile等，有了這個萬用的Entity後，即可透過簡單的方式更新各自Entity的循環\n// 程式中的主循環 function update(dt, tickcount) { let entities = world.gameObjs; // 更新所有物體  for (const entity of entities) { entity.update(dt); } // 逐一檢測各Entity的事件觸發器  for (let i = entities.length - 1; i \u0026gt;= 0; i--) { let entity = entities[i]; let had = entity.hitActionData; if (!had) continue; // 此物體沒有觸發器的話就直接跳過  for (let j = entities.length - 1; j \u0026gt;= 0; j--) { let entity2 = entities[j]; // 判斷這個物體是否在觸發器的目標中  if (had.target.indexOf(\u0026#39;ALL\u0026#39;) != -1 || had.target.indexOf(entity2.name) != -1) { // 執行觸發器對應的處理  had.action(entity, entity2); } } } // 檢測那些物體該被移除  for (let i = entities.length - 1; i \u0026gt;= 0; i--) { const entity = entities[i]; if (entity.isDead) entities.splice(i, 1); } // camera.follow(dt, player);  cameraControl();// 更新攝影機位置 } 碰撞效能的優化 Quadtree_in_2d\n如果每個物體之間都進行碰撞檢測，會消耗大量的效能，複雜度來到O(N^2)\n例如: 兩物體在地圖的對角線，根本不會碰撞，但還是執行檢測\n透過四叉樹(Quad Tree)來進行空間上的劃分\n將複雜度降低至O(N log(N))\n   \n架構與後續規劃  UI選單、Menu、功能列操作 對話方塊與對話事件(對話樹) 腳本編輯與腳本觸發器，如RPG遊戲中的串場事件 優化物件架構，方便修改   簡易架構圖 \n檔案架構 ├─asset │ ├─data │ ├─img │ ├─sound │ └─tile │ │ Camera.js │ Collision.js │ Enemy.js │ Entity.js │ index.html │ main.js │ Particle.js │ Player.js │ player2.js │ Setting.js │ Shape.js │ Tilemap.js │ └─lib AssetLoader.js drawString.js Game.js SpriteAnimation.js stats.min.js utils.js vec.js 參考資料 https://gablaxian.com/articles/creating-a-game-with-javascript/introduction http://isaacsukin.com/news/2015/01/detailed-explanation-javascript-game-loops-and-timing\n","date":"2020-12-04T02:16:07+08:00","image":"https://davidhsu666.com/archives/2dgame-nonename/img/123213487.png","permalink":"https://davidhsu666.com/archives/2dgame-nonename/","title":"從零開始的基礎RPG框架"},{"content":"工科賽-軟體設計 歷屆試題解答 前言: 名次不高，這篇文只是單純分享，想看高手的心得，直接Google “ACM ICPC 心得”\n我是106屆工科軟體競賽選手，覺得高職選手的資源不是很多，如果沒有老師、學長指導、沒有解答、也沒有累積相關知識技術的底，想拿前段名次會辛苦很多。\n先簡單講講，所以可能有點亂，主要是該寫甚麼我也不清楚，工科軟體跟TOI比起來，知名度跟難度都差滿多的，所以也沒什麼人在關注或是討論題目，資源自然就少，大多只能靠學長或老師傳承解答。\n高職的比賽，沒興趣不太建議靠比賽升學，做選手學東西就行，因為沒有很好的名次加上備審，不好上前段國立，所有國立科大資工開放的總名額大概只有30個左右，採計的比賽也不只工科賽，所以就算前15名也不見得能上國立。\n全國工科技藝競賽 軟體設計在比什麼: 簡單來講就是用程式邏輯來解各種應用問題，但比UVA、IOI簡單，比較偏向應用一些吧，可以翻下面的題庫來看看在比什麼。 像是8-Puzzl轉盤，要在解題的時候去思考，如何讓電腦找到最少步數，相比傳統解題競賽，較著重在功能呈現上。\n BFS解8-Puzzle \n相關文章: 用BFS解8-Puzzle問題\n準備方式: 語言建議用C#(至少要會哪些之後再補好了)。\n建議是在暑假的時候先看完一到兩本演算法或資料結構的書(推薦啊哈!圖解演算法、大話資料結構)，每天看一個段落，理解後就實做一次，很快就能看完了，以我來說大約一個月。\n差不多開學後，開始練習工科賽題目，我是覺得工科賽歷屆題目就直接拿來計時比較實在，不然沒人幫你出題目，要想出能提升自己技術的題目內容其實挺難的，然後在11月前把工科北軟歷屆解完。\n11月前記得也要寫學科，學科這邊就不用寫太多，覺得自己的相關知識差不多後，寫工科的99~104，如果每張不看解答或查資料，都有90左右，就差不多了，建議寫完就算對了也要在旁邊補上解法，這樣到時候比賽前複習才比較方便。\n接著11月初，如果你是台北人，建議參加北軟，模擬一些臨場感，因為當你有所準備時，上場真的會很緊張，不然也沒什麼機會能模擬比賽了….。就算不是也沒關係，北軟比完會釋出題目，把它全部做完。\n接著補一些自己當初不會或是卡住的內容，花點時間研究，並給自己出模擬試題，檢查自己哪些觀念不太夠。\n如果你都完成了，就準備比賽拿金手吧。\n雜談: 要拿金手比IOI培訓營簡單很多，感覺教育部也沒特別規定高職的程式設計課程要怎麼上，就變成看學校老師個人造化的感覺。\n別校選手說他們老師也是不推薦比賽，他參賽的原因只是科排第一，被科主任盧過來的。\n全台60幾所高職報名軟體設計，真正有在訓練選手的也就那幾間，感覺其他很多都是被學校盧過來參加，或是覺得有趣隨便報名，反正校內選拔也沒人在搶，所以比賽水平自然沒有IOI那麼高。\n大概是這樣吧，我自己還有一些想法跟心得，只是不曉得怎麼寫。 剩下看要問什麼吧，一些比較深的演算法，我答不出來可以去這一串問，滿多人可以幫忙的。\n電腦修護那塊，我伺服器沒什麼研究，單晶片當初有協助同校選手，所以還算幫得上忙吧，有問題可以問問看。\n解答: 歷屆題目的程式碼，這些題目解答都是我自己寫的，雖然寫得很爛，但至少能解出題目要求的解答，所以寫法有看不懂的地方，我看一下題目跟Code都能回答。\n這邊放北軟的歷屆，主要是我覺得北軟的題型跟工科賽幾乎一樣，而且出題老師也跟工科賽有重疊，因為這幾年都有類似的題目出現，加上北軟在工科賽之前比，非常值得做參考。\n工科賽軟體設計: 歷屆題目 : Here 96~106屆參考解答 : Here\n北市軟體設計競賽(高工): 歷屆題目 : Here 99~106屆參考解答 : Here\n","date":"2019-11-06T09:38:44+08:00","image":"https://davidhsu666.com/archives/skills-competition-software/img/skill_img1.jpg","permalink":"https://davidhsu666.com/archives/skills-competition-software/","title":"工科賽-軟體設計 歷屆試題解答"},{"content":"Vector Reflection 這篇文應該是要跟MTV(Minimum Translation Vector)的碰撞回饋一起寫，但MTV發起來有點長，懶得打，先記錄Vector Reflection\n為什麼需要取得鏡射向量(Vector reflection) 一個簡單的例子，當乒乓球擊中球拍時，要如何取得反彈後的向量，而光影模擬時也會需要取得光線反射的向量，這時向量反射就非常重要了。\n因為這篇內容比較基礎，所以一些基本部份就省略了\n如何取得Vector reflection  V1打到Axis上，並反彈至V2 \n先定義一些資訊:\n V1 = 物體的速度 V2 = 物體反彈後的速度 N = 擊中平面的法向量  如何取得擊中平面的法向量 N 呢?\n很簡單，透過兩垂直向量點積為0的特性就可以得到，假設Axis是(3, 4)的向量，那平面法向量就會是(-y, x) = (-4, 3) 或是 (y, -x) = (4, -3)  左/右法向量 \n再來看如何取得 V2\n將V1與V2之間畫一條線，並組合成一個平行四邊形，這樣就很明顯得到 V2 = 2N' + V1，那麼接下來的問題就會是如何取得N'。  img \n先只單看V1跟法向量N，可以發現N' 其實就是V1在法向量N上面的投影$proj_{\\hat n}V_{1}$，所以可以透過基本三角函數來取得\n但$\\cos \\theta$需要另外計算夾角，所以有個更好的方法來代替，在點積公式中，使其中一個向量為單位向量，因為長度為1可直接省略，所以$\\left |V_{1} \\right | \\cos \\theta = V_{1} \\cdot \\hat{n}$，要加負號是因為$V1$與$\\hat{n}$為反方向，$\\left |V_{1} \\right | \\cos \\theta$會是帶負號的純量，但我們需要的$\\hat{n}$是與$V_{1}$反向的，所以加上負號:\n 法向量n可透過正規話取得 \n而$(V_{1} \\cdot \\hat{n})\\hat{n}$就是快速求得$V_{1}$在法向量$\\hat{n}$投影的方式: $$proj_{\\hat n}V_{1}=(V_{1} \\cdot \\hat{n})\\hat{n}$$\n再來回到$V_{2} = 2N' + V_{1}$\n該有的東西都有了，所以整理後可以得到:\n$$V_{2} = V_{1} - 2(V_{1} \\cdot \\hat{n})\\hat{n}$$\n V1 = 物體方向 n = 擊中平面的\u0026quot;單位\u0026quot;法向量 v2 = 反彈後的方向  接者就可以放在當物體與某個平面碰撞後，更新反彈後的速率為V2，就會有乒乓球反彈的效果了\n大概就這樣，具體結果可以參考:從零開始的基礎RPG框架\n參考資料  Basic Ad Hoc Collision Response 3D Programming Weekly:Graphics:Reflecting a Vector How to get reflection vector?  ","date":"2019-04-26T03:58:47+08:00","image":"https://davidhsu666.com/archives/math-for-game-vector-reflection/img/13fig21.gif","permalink":"https://davidhsu666.com/archives/math-for-game-vector-reflection/","title":"Vector reflection向量鏡射 基本的碰撞反彈回饋"},{"content":"Source Code : Link\nC# Tic-Tac-Toe 與電腦對戰OOXX\n \nC# 五子棋 透過累計棋盤分數加權的方式，來完成電腦VS玩家的互動\n \nC# Ball game 平面射擊遊戲，敵人會一直追著玩家，透過WASD移動，滑鼠左鍵射擊，想嘗試模仿diep.io\n \njs_pingpong 乒乓球對打\n線上執行 : Link\n第一次學JS，讓我對一些2D平面遊戲撰寫更有了解  \njs_memorygame 翻牌記憶遊戲\n線上執行 : Link\n \njs_snake 經典貪食蛇\n線上執行 : Link\n \njs_gerrnrainT 仿造駭客任務的特效\n線上執行 : Link\n \njs_AsteroidGame 宇宙飛機打隕石\n第一次認識Coding train這個頻道，從接觸這頻道後讓我有了一個契機去了解各式演算法與應用\n線上執行 : Link\n參考Coding train : https://www.youtube.com/watch?v=hacZU523FyM\n \njs_Minesweeper 踩地雷，線上執行 : Link\n \njs_dragTest 嘗試製作簡易圖形物件\n線上執行 : Link\n \n","date":"2018-12-01T00:00:00Z","image":"https://davidhsu666.com/archives/toy-project/img/front.png","permalink":"https://davidhsu666.com/archives/toy-project/","title":"Toy project 小程式合輯"},{"content":"碰撞檢測的優化-四叉樹(Quadtree) 許多遊戲都會需要碰撞檢測來判斷兩物體的碰撞，但這些演算法通常是較為昂貴的操作，如果無法有效率的選擇檢測目標，很可能會大幅降低執行的速度。(像是之前提到的SAT碰撞檢測)\n在之前的”多邊形碰撞檢測”文中，也有提到當檢測物體越來越多時，基本逐一檢測的效率會越來越差，複雜度約為O(n^2)，就算排除重複檢測過的物體，只要是逐一檢測的方法就一定會走訪所有物件。\n \n從上圖可以得知直接全部檢測的話是4 x 5 = 20，如果扣掉重複，至少是4 + 3 + 2 + 1 = 10，但真正的問題是，就算1和3距離這麼遠，也照樣會檢查它們，那有沒有方法能解決這種狀況呢?\n這就是文章的主要內容，QuadTree。\n1. 什麼是QuadTree? 四叉樹(QuadTree)是一種劃分2D區域的樹狀資料結構，類似一般的二元樹，但子節點是4個，而不是2個。\n區域的劃分架構類似這樣 :\n 將區域分成四塊   每塊再往下劃分   加入多個物體後的效果   運行效果，點圖放大 \n並限制每個區域能容納的上限，當超過後就將該區域再往下分割4塊，這樣就能夠將每個物體進行區域分類，這樣在檢查的時候就可以鎖定部分區域的物體，從而增加效率。\n2. 插入流程: 假設我先設定每個區域只能容納4個物體，只要超過該容量，就要分割該區域。\n左圖方形區域已經有4個物體，想再加入第5個時，就必須分割成4個子區域，再將第5顆分類到最近的左上角區域中，如右圖:\n 超過容量時擴展子樹 \n以此類推，當要放入第9顆物體時，發現黑色區域也滿了，所以就再往下分割紅色區域，並放入離該物體最近的右下角區域中，如下圖:\n 此區域也超過後，繼續擴展下去 \n最後，就可以得出這樣的樹狀結構，這就是為什麼會叫做4叉樹的原因，如下圖:\n 完整流程 \n3. 搜尋流程: 給定一搜尋範圍，並逐一排除不可能的區域，最後取得搜尋範圍內的物體。\n接續前面插入的狀態，假設我要檢測綠色框框內的物體是否發生碰撞，步驟如下 :\n 與藍框區域作碰撞檢測，發現有所交集，檢測藍色區域的物體是否包含在綠框中，發現並沒有。 與藍框的黑色子區域作檢測，發現只與左上的區域有所交集，所以排除另外三個區域，並發現有2個物體包含在綠框內。 再往下檢察左上黑框的紅色子區域，並排除左上、左下，發現有3個物體在綠框內，紅框沒有子領域，走訪結束。  最後回傳搜尋到的5個物體。\n 搜尋步驟   大致流程 \n如果是碰撞檢測的應用的話，就是把綠框換成該物體周圍可能發生碰撞的範圍，再來套入搜尋，就能更加簡化碰撞檢測的流程，如下圖 :\n 給定搜索形狀 \n假設要檢查綠色圈圈與那些物體發生碰撞，透過前述的篩選流程，搜尋到最後，只要針對和綠圈區域相交的3個物體檢測就好，以此達成碰撞效率優化。\n這就是四叉樹的原理，接著進入實作環節吧。\n4. 實作QuadTree–插入 先整理大致的插入順序:\n 如果該點不屬於A區域，直接結束 如果該點屬於A區域，且A區域容量還夠的時候，將該點加入A區域 如果A區域容量不夠時，將A區域劃分4個子區域，並將該點加入離它最近的子區域  建立基本物件 :\nclass Point { constructor(x, y) { this.collisionType = \u0026#34;point\u0026#34;; this.x = x; this.y = y; } } class Rect { constructor(x, y, w, h) { this.collisionType = \u0026#34;rect\u0026#34;; this.x = x; this.y = y; this.w = w; this.h = h; } } 四個子區域的規劃:\n 定義每塊區域的範圍 \n並依照前述所說的插入順序，來建立QuadTree :\nclass QuadTree { constructor(boundary, level) { this.MAX_OBJ = 4;// 該容器最大容量  this.MAX_LEVEL = 5;// 最大深度  this.objs = [];// 該容器的物體集合  this.areas = [];// 四塊子區域  this.level = level || 1;//當前深度  this.boundary = boundary;// 容器範圍(Rect)  } /* 如果該點在範圍內，且容量也夠的話就新增該點至區域內，或是到達最大深度也直接新增 到達容量上限後，就分割出四個子領域，再將物體分類至最靠近的子領域中 */ insert(object) { // 先確認物體是否在邊界內  if (!CheckCollision(this.boundary, object)) return false; // 如果當前容量與深度未達上限，就直接新增該物體  if (this.objs.length \u0026lt; this.MAX_OBJ || this.level \u0026gt;= this.MAX_LEVEL) { this.objs.push(object); return true; } // 如果容量達上限，且沒有子領域的話，分割出四個子領域  if (this.areas.length \u0026lt;= 0) this.subdivide(); // 嘗試給子領域新增該物體  for (let area of this.areas) { if (area.insert(object)) return true; } } subdivide() { let x = this.boundary.x, y = this.boundary.y; let w = this.boundary.w, h = this.boundary.h; // 矩形以左上為基準，依照各象限順序建立子領域，並新增到areas中  this.areas.push(new QuadTree(new Rect(x + w / 2, y, w / 2, h / 2), this.level + 1));// topRight  this.areas.push(new QuadTree(new Rect(x, y, w / 2, h / 2), this.level + 1));// topLeft  this.areas.push(new QuadTree(new Rect(x, y + h / 2, w / 2, h / 2), this.level + 1));// bottomLeft  this.areas.push(new QuadTree(new Rect(x + w / 2, y + h / 2, w / 2, h / 2), this.level + 1));// bottomRight  } show(ctx) { // 繪製邊界  ctx.strokeStyle = \u0026#34;#FFF\u0026#34;; ctx.strokeRect(this.boundary.x, this.boundary.y, this.boundary.w, this.boundary.h); // 顯示物體數/容量數，Debug  drawString(ctx, this.objs.length + \u0026#34;\\n\u0026#34; + this.MAX_OBJ, this.boundary.x + this.boundary.w / 2, this.boundary.y + this.boundary.h / 2, \u0026#34;rgba(255,255,0,0.5)\u0026#34;, 10, \u0026#34;consolas\u0026#34;, 0, 0, 0); // 往下繪製所有子領域區塊  if (this.areas.length != 0) { for (let area of this.areas) { area.show(ctx); } } // 繪製出這塊領域的物體  for (let obj of this.objs) { ctx.beginPath(); ctx.arc(obj.x, obj.y, 3, 0, Math.PI * 2); ctx.stroke(); } } } 至於程式中CheckCollision(ObjectA, ObjectB)，就是單純的點與矩形的碰撞檢測，請參考結尾附上的Code。\n使用方法 :\n// 建立QuadTree var qt = new QuadTree(new Rect(0, 0, Width, Height)); // 新增物體 qt.insert(new Point(X, Y)); // 在Canvas中顯示分割與物體狀況 qt.show(Context); 如此一來就能建立基本可新增物體的QuadTree了。\n基本插入範例，滑鼠點擊即可新增物體。新視窗執行 : Here\n 然後可以看到，每當一個區域插入4個物體後(MAX_OBJ = 4)，就會將該領域往下分割4個子區域，最多分割5層(MAX_LEVEL = 5)。\n5. 實作QuadTree–搜尋 搜詢的大致順序 :\n 如果搜尋範圍跟當前領域相交，檢查該領域有多少物體包含在搜尋範圍中，並增加至陣列中 當該領域有子區域時，繼續往下檢查有多少物件包含在搜尋範圍內 直到所有搜尋範圍內的區域都被檢測過，回傳所有在搜尋範圍內的物體  可以比對一下上面講的搜尋流程，應該會更清楚。\n根據上述步驟，在QuadTree中加入query這個function :\nquery(range, found){ // 如果沒有給定回傳的陣列，就建立一個  if(!found) found = []; // 判斷搜尋範圍(range)是否與當前領域有相交，沒有就直接跳掉，以節省效率  if (!CheckCollision(this.boundary, range)) return; // 如果搜尋範圍跟當前領域相交，檢查該領域有多少物體包含在搜尋範圍中，並增加至found  for(let p of this.objs){ if (CheckCollision(p, range)){ found.push(p); } } // 當該領域有子區域時，繼續往下檢查有多少物件包含在搜尋範圍內  if(this.areas.length != 0){ for(let area of this.areas){ area.query(range, found); } } // 完成搜尋，回傳結果  return found; } 而使用方法也非常簡單，給定一個搜尋區域，接著query就會直接撈出所有在搜尋範圍內的物體了 :\n// 假設queryTree已經新增一些物體了 // 建立一個搜尋範圍 var checkRange = new Rect(20, 40, 150, 150); // 套用搜尋範圍至queryTree取得範圍內的物體 var objects = queryTree.query(checkRange); 基本搜尋範例，滑鼠點擊新增物體，移動可取得範圍內的物體。新視窗執行 : Here\n 6. 實際應用 我將正常的碰撞檢測與QuadTree檢測放在一起做比較，可以清楚的看到，當物體數量到2000時，No QuadTree的檢測方法已經無法負荷，畫面有明顯卡頓。換成QuadTree檢測後，就只掉一點FPS，透過比對，可以明顯看到效能的提升。\n每當物體碰撞時變成白色，滑鼠點擊新增100個物體，按下按鈕以切換不同檢測模式，觀察效能的差距 :\n在新視窗執行 : Here\n 7. 總結 QuadTree或許不是最好的多物體檢測法，但多數狀況下還堪用，至於QuadTree優化的部分，可以參考這篇文章，講得非常清楚。\n這邊預計要再補上QuadTree跟其他檢測法的優缺點，但目前只研究QuadTree，所以無從比較，日後補上。\n文章中所有的Source Code都在Github中 : https://github.com/md9830415/JS-QuadTree\n大概就是這樣了，下期再見，掰掰。\n8. 參考資源  Coding Challenge #98.1: Quadtree – Part 1 Quick Tip: Use Quadtrees to Detect Likely Collisions in 2D Space Efficient (and well explained) implementation of a Quadtree for 2D collision detection JavaScript QuadTree Implementation  ","date":"2018-10-27T07:31:13+08:00","image":"https://davidhsu666.com/archives/quadtree_in_2d/img/Quad_013.png","permalink":"https://davidhsu666.com/archives/quadtree_in_2d/","title":"碰撞檢測的優化-四叉樹(Quadtree)"},{"content":" \n點此遊玩 : ver.0.3\nSource Code : Github\n遊玩方式 :\n 移動方塊 : 左鍵、右鍵 往下移動 : 下鍵 直接放置方塊 : 空白鍵 保留/交換方塊 : C鍵  遊戲目標 : 越高分越好\n目前功能:\n 基本操作與消除 底部的方塊位置預覽 能從右側得知接下來的方塊  ","date":"2018-09-05T00:00:00Z","image":"https://davidhsu666.com/archives/js-tetris/img/Tetris03.gif","permalink":"https://davidhsu666.com/archives/js-tetris/","title":"俄羅斯方塊"},{"content":"JS Firework 跨年煙火  \n買不起煙火沒關西，自己模擬一個就行了。 最近剛好學會一些特效，就順便寫個簡易粒子效果，來做個跨年煙火。\n可以到此連結遊玩，使用滑鼠左鍵施放煙火 :\n連結 : Click Here\nGitHub : Click Here\nHappy new year !!! ","date":"2018-08-31T10:55:51+08:00","image":"https://davidhsu666.com/archives/js-firework/img/firework3.gif","permalink":"https://davidhsu666.com/archives/js-firework/","title":"JS Firework 跨年煙火"},{"content":"1. 前言 先來簡單的介紹一下什麼是8-Puzzle。\n數字推盤遊戲(n-puzzle)是最早一種的滑塊類遊戲，常見的類型有十五數字推盤遊戲和八數字推盤遊戲等，也有以圖畫代替數字的推盤遊戲。\n Wiki上的8Puzzle \n如上圖所示，滑塊只能往空位移動。\n大概了解遊玩方法後，就來試著解決8-Puzzle問題吧!\n解法的步驟大概是這樣 :\n 先完成移動判斷和節點狀態的儲存結構 用BFS窮舉狀態，並把當前狀態記錄下來篩選重複路徑 只要有一組路徑符合結果，該路徑就是最佳解(因BFS的特性是每次平均向外擴展，所以最先碰到終點的就是最佳解之一) 否則搜尋完畢後皆沒有找到符合的狀態，無解 最後透過父節點的回溯取得輸出路徑，即可得到最短路徑和分解步驟  2. 儲存結構和移動判斷 首先是儲存狀態，用二維陣列來儲存比較直觀，但是用一維陣列來儲存的話，我覺得在一些處理上比較方便，所以我採用一維陣列。\n 資料結構 \n像是上面的這個狀態這樣，將0表示為空格，可以儲存成 { 8, 6, 4, 0, 7, 2, 5, 1, 3}。\n因為要透過BFS搜尋來取得路徑，所以需要建立一個節點的結構，這樣才能儲存當前狀態，並紀錄上個狀態 :\npublic class Node { public byte[] status; // 當前狀態  public Node father; // 紀錄上個狀態，如果father = null 該點為根節點  public Node(byte[] status, Node father) { this.status = status; this.father = father; } // 把陣列轉換成數字序列，比對時就不用兩將陣列元素一一檢查了  // 像是 stauts = {8, 6, 4, 0, 7, 2, 5, 1, 3}，轉後後即可得到864072513  public int ToToSequence() { int result = 0; for (int i = 0; i \u0026lt; status.Length; i++) result = result * 10 + status[i]; return result; } } 再來是移動判斷，滑塊在移動時，可以看成是空白方塊在移動。\n \n如上圖，0 可以往上、右、下移動，但是不能往左，那麼要如何判斷0能往哪個方向走呢?\n \n如上圖，當 index = 3 時，可以得知在二維時座標是 (0, 1)。\n能取得對應位置後，就能夠寫出移動判斷，像是當空位在最左邊時Col = 0，那麼就不能往左走，因為在最左邊了，在最下面時Row = 2，不能往下走，因為已經到底了。\n所以可以得出:\n Col != 0，可以往左走 Col != 2，可以往右走 Row != 0，可以往上走 Row != 2，可以往下走  但是只有判斷能不能走還不夠，因為當空格移動時，必須跟那個位置的數字交換，並記錄下原本的狀態 :\nList\u0026lt;Node\u0026gt; GetNext(Node now)// 傳入當前版面，回傳0所有移動後的狀態 { int index = Array.IndexOf\u0026lt;byte\u0026gt;(now.status, 0); int col = index % 3; int row = index / 3; List\u0026lt;Node\u0026gt; nextPush = new List\u0026lt;Node\u0026gt;(); byte[] next; if (row != 0) // Top  { next = (byte[])now.status.Clone(); swap(ref next[index], ref next[index - 3]);// 跟上面交換  nextPush.Add(new Node(next, now));// 加入這個新狀態  } if (col != 2) // Right  { next = (byte[])now.status.Clone(); swap(ref next[index], ref next[index + 1]);// 跟右邊交換  nextPush.Add(new Node(next, now)); } if (row != 2) // Bottom  { next = (byte[])now.status.Clone(); swap(ref next[index], ref next[index + 3]);// 跟下面交換  nextPush.Add(new Node(next, now)); } if (col != 0) // Left  { next = (byte[])now.status.Clone(); swap(ref next[index], ref next[index - 1]);// 跟左邊交換  nextPush.Add(new Node(next, now)); } return nextPush; } 在交換前要先複製一份，因為陣列參數是傳參考，直接交換會修改到原本的狀態，所以要先Clone後再傳給新狀態做交換。\n而上面程式碼中 new Node(next, now)，意思是建立一個新節點next，而他的前一個狀態是剛剛傳進來的now。\n \n如上圖，假設now是根結點，而next是下個節點，那麼new Node(next, now)後就會像這樣。\n3. 用BFS窮舉狀態 有了移動判段後，接下來的解法就跟用BFS解迷宮差不多了 :\n// 傳入原本的版面和目標版面，回傳最短路徑 List\u0026lt;Node\u0026gt; Solve(byte[] source, byte[] goal) { Queue\u0026lt;Node\u0026gt; queue = new Queue\u0026lt;Node\u0026gt;(); // 使用狀態序列來儲存已走過的路徑，防止往回走  SortedList\u0026lt;int, bool\u0026gt; book = new SortedList\u0026lt;int, bool\u0026gt;(); Node end = new Node(goal, null);// 終點  Node start = new Node(source, null);// 起點  queue.Enqueue(start);// 推入起點  book.Add(start.ToSequence(), true);// 標示起點已走過，防止走回頭路  int endStatus = end.ToSequence(); while (queue.Count \u0026gt; 0) { // 取得當前搜索狀態，並移出佇列  Node now = queue.Dequeue(); // 如果抵達終點，那就輸出路徑  if (now.ToSequence() == endStatus) return PathTrace(now); // 取得能走的位置  List\u0026lt;Node\u0026gt; nextPath = GetNext(now); foreach (var path in nextPath) { int sign = path.ToSequence(); // 判斷當前節點狀態是否擴展過了  if (!book.Keys.Contains(sign)) { // 推入當前狀態，並標記該路徑已走過，因為每個狀態只需要擴展一次就夠了  queue.Enqueue(path); book.Add(sign, true); } } } // 如果窮舉完都沒找到，代表無解  return null; } List\u0026lt;Node\u0026gt; PathTrace(Node now) { // 回朔路徑  List\u0026lt;Node\u0026gt; path = new List\u0026lt;Node\u0026gt;(); while (now.father != null) { path.Add(now); now = now.father; } path.Reverse(); return path; } 路徑的儲存使用SortedList而不是正常的List，因為List在加入物件時並不會特別處理，所以在搜尋時就只能慢慢比較，而 SortedList的結構類似二元搜尋樹，在新增資料時就會依照設定的Key值做排序後再插入，所以在搜尋時的複雜度就能夠降到O(log2 n)，想了解更多的話請看最後的參考資源。\n到這邊大概就能了解為什麼要用ToSequence()來儲存路徑了，因為資料不會重複，所以搭配SortedList就比List快的多。\n使用方法:\nbyte[] source = new byte[] { 8, 6, 4, 0, 7, 2, 5, 1, 3 }; byte[] goal = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 0 }; List\u0026lt;Node\u0026gt; path = Solve(source, goal); Console.WriteLine($\u0026#34;最少步驟為:{path.Count}\u0026#34;); 給定原本面狀態跟輸出狀態，即可得到最短路徑的List，而輸出路徑只要走訪一遍Path即可得到。\n其實執行的原理很簡單，就是一直窮舉所有狀態，直到符合結果為止\n \n4. 執行結果  \nSource Code : Here\n雖然用BFS就能解了，但效率很差，之後會再研究看看A*演算法。\n5. 參考資源  What’s the difference between SortedList and SortedDictionary? : here 各Collection陣列個別特性列表 : here 8-Puzzle : here ACM 15-puzzle : here Inndy GitHub : here  ","date":"2018-06-22T10:04:35+08:00","image":"https://davidhsu666.com/archives/csharp-bfs-solve-8-puzzle/img/8puzzle07.jpg","permalink":"https://davidhsu666.com/archives/csharp-bfs-solve-8-puzzle/","title":"BFS解8-Puzzle問題"},{"content":"浮點數誤差IEEE-754 在程式語言中，浮點數基本都是用 float 與 double來表示，但都會存在誤差\nfloat t1 = 0.69 * 10; cout \u0026lt;\u0026lt; setprecision(32) \u0026lt;\u0026lt; t1 \u0026lt;\u0026lt; endl; if(t1 == 6.9) cout \u0026lt;\u0026lt; \u0026#34;相等\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;不相等\u0026#34; \u0026lt;\u0026lt; endl; // output // =\u0026gt; 6.900000095367431640625 // =\u0026gt; 不相等 正常6.9 * 10 應該要等於6.9，但是答案卻是不相等?\n這個原因跟浮點數的儲存原理有關，讓我們開始吧!\n何謂IEEE-754 自電腦發明以來，曾出現過各種不同的浮點數表示法，但目前最通用的是IEEE二進制運算標準(IEEE Standard for Binary Floating-Point Arithmetic , 簡稱IEEE-754)\n在IEEE-754標準中定義了四種浮點數格式，但我只講基本的兩種，分別為單精準度float(32bit)和雙精準度double(64bit)。其中單精準度有24位有效儲存數字，而雙精準則有53位有效數字，相對於十進位來說，分別是7位(224 = 107)和16位(253 = 1016)。\n為了方便說明，所以先解釋什麼是正規化\n正規化就像是數學中的科學記號，如123456通常會表示成1.23456 x 105，而指數部分也有可能是負的，如 0.123456 就會變成 1.23456 x 10-1。\n二進位的正規化 :\n這邊以13.125為例，先13轉換為2進制，可得1101，再將0.125轉為2進制\n 0.125 x 2 = 0.25 … 整數為0 -\u0026gt; 0 0.25 x 2 =0.5 … 整數為0 -\u0026gt; 0 0.5 x 2 = 1 … 整數為1 -\u0026gt; 1  所以13.125 = 1101.001，經過正規化後可得 1.101001 x 23\n在IEEE-754中，浮點數通常由三個部分組成 :\n 符號(S) : 用來表示正/負(0/1)。 指數(E) : 正規化後的次方數，採用超127格式，即將原本的次方數加上127，因為次方數有可能是負的，加上在電腦中要表示負號時，必須拿一個位元來表示，所以就將-128~+127改為0~255，所以基準點就從0變成127。 尾數(M) : 正規化後的小數點。  以下範例皆為單精準度 :\n \n浮點數與10進制的轉換 以剛剛的 13.125 轉浮點數為例 :\n 由於13.125為正，所以符號(S) = 0 先將數值轉成二進位並正規化 13.125 = 1101.001 = 1.101001 x 23 計算指數(E) = 127 + 3 = 01111111 + 11 = 10000010 計算尾數(M) = 101001，因為正規化後一定是1.xxxx，所以不需要儲存個位數 將各個數值填入浮點數規格中\nS——–E———————M———————–\n0 10000010 101001 0000 0000 0000 0000 0  這樣就就完成了10進制轉IEEE-754浮點數\n而浮點數轉10進制也是一樣\n將剛剛的0 10000010 10100100000000000000000轉10進制 :\n 由於S = 0，所以此數為正 中間8位元的超127指數(E)為 100000102，將其還原130 – 127 = 100000102 – 01111112 可得 3 = 112 所以要將尾數乘上23 最右邊23個為位元值為101001……，將隱藏的個位數還原，可得1.101001…… 最後將還原後的尾數乘上指數 1.1010012 x 23，並轉為10進位，即可得到 13.125  所以我們可以知道，以32bit的單精度浮點數來說，可以儲存的最大位數為 尾數 23+隱藏個位數 1 = 24位。\n關於浮點數的精度 因為有些10進制小數無法完美的用2進制表示，只能用無限的位數來趨近於10進制小數，當我們以24位數為上限時，在儲存時就會省略一些位數，導致還原時的數字不夠精準。\n從以下範例可以得知精確的數字總共7位數\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt;using namespace std; int main() { float t1 = 0.69 * 10; cout \u0026lt;\u0026lt; setprecision(32) \u0026lt;\u0026lt; t1 \u0026lt;\u0026lt; endl; //output =\u0026gt; 6.900000095367431640625  float t2 = 0.1234567; cout \u0026lt;\u0026lt; setprecision(32) \u0026lt;\u0026lt; t2 \u0026lt;\u0026lt; endl; //output =\u0026gt; 0.12345670163631439208984375  float t3 = 123.4567; cout \u0026lt;\u0026lt; setprecision(32) \u0026lt;\u0026lt; t3 \u0026lt;\u0026lt; endl; //output =\u0026gt; 123.45670318603515625 \tfloat t4 = 16777216, t5=0.5; float t6 = t4 + t5; cout \u0026lt;\u0026lt; setprecision(32) \u0026lt;\u0026lt; t6 \u0026lt;\u0026lt; endl; //output =\u0026gt; 16777216  return 0; } 參考資源  IEEE 浮點運算標準 : here C 語言取出/設定浮點數正規化欄位 : here C/C++ 浮點數特殊值 : here [C\u0026amp;C++] 浮點數精準度 (Floating-Point Precision) : here IEEE-754 浮點數的表示法 : here MSDN IEEE 浮點表示 : here Binary floating point and .NET : here What Every Computer Scientist Should Know About Floating-Point Arithmetic : here C语言浮点型数据存储结构 : here IEEE754规范的舍入方案怎么理解呢？ : here  ","date":"2018-05-22T10:29:44+08:00","image":"https://davidhsu666.com/archives/ieee-754/img/ieee754.jpg","permalink":"https://davidhsu666.com/archives/ieee-754/","title":"浮點數誤差IEEE-754"},{"content":"JS 超級球球SuperBall 這小遊戲是我第一個破千行程式碼的專案，前前後後花了2個月左右，花了很多時間在想架構跟遊戲特效的呈現，到目前的進度算是有點成果，放到網站做個記錄。\n遊戲連結 ver.0.2.3 : Click Here\nsource code : Github\n遊玩方式 移動 : 鍵盤上下左右\n攻擊 : 自動攻擊\n目標 : 通過 8 關\n敵人\n 藍球 : 普通型 紅球 : 速度型 綠球 : 坦克型  這三種敵人都有四種大小，且擁有分裂功能，最多分裂四次\n道具:\n 黃色方塊 : 強化 增加攻擊速度，在累積到一定量時會進化，增加子彈數量，掉落機率10% 白色方塊 : 全屏敵人緩速30%，掉落機率1.5% 紅色方塊 : 補包，增加一格血量，稀有道具，掉落機率0.1%   任務成功   任務失敗 \n 遊戲畫面 \n","date":"2018-03-21T11:05:37+08:00","image":"https://davidhsu666.com/archives/js-superball/img/smallballgame1.png","permalink":"https://davidhsu666.com/archives/js-superball/","title":"JS 超級球球SuperBall"},{"content":"我在網路上搜尋到一些解決方法，在這裡做個整理。\n正常更新畫面的方法都是先將畫面清空後，再將新的畫面畫上去，\n導致清空的剎那，好像畫面閃爍了\n \n解決方法:\n 畫面重繪時，不直接在螢幕上重繪，而是先畫在緩衝區，等整個畫面都重繪完成，才一次放到螢幕上。 想像我們用兩張紙來做更新，一張紙是當前畫面，另一張是緩衝區，在更新時把圖畫在第二章紙上，畫完後再一次把這張紙覆蓋到主畫面。  1.把DoubleBuffered 屬性設為 true。(參考自C# MSDN使用表單和控制項的雙重緩衝)\npublic Form1() { InitializeComponent(); this.DoubleBuffered = true; } 2.使用 BufferedGraphicsContext 。(參考自MSDN手動管理緩衝的圖形)\nfloat x = 0, y = 0; public Form1() { InitializeComponent(); timer1.Interval = 1000 / 60; timer1.Start(); } private void timer1_Tick(object sender, EventArgs e) { x += 1; BufferedGraphicsContext currentContext = BufferedGraphicsManager.Current; BufferedGraphics myBuffer = currentContext.Allocate(this.CreateGraphics(), this.DisplayRectangle); //清除繪圖畫面，並用原本的背景色填充，否則背景呈現黑色  myBuffer.Graphics.Clear(this.BackColor); //在圖形緩衝區中畫圖  myBuffer.Graphics.DrawEllipse(Pens.Blue, x, y, 70, 70); //將圖形緩衝區的內容畫到指定的畫布上  myBuffer.Render(this.CreateGraphics()); //釋放緩衝區的資源  myBuffer.Dispose(); this.Refresh(); this.Invalidate(); } 3.使用Bitmap。(參考自Gary Lin 的 C# 遊戲程式設計)\n較推薦使用這種方式\nfloat x = 0, y = 0; Graphics backGraphics; Bitmap backBmp; public Form1() { InitializeComponent(); backBmp = new Bitmap(this.DisplayRectangle.Width , this.DisplayRectangle.Height); backGraphics = Graphics.FromImage(backBmp); timer1.Interval = 1000 / 60; timer1.Start(); } private void timer1_Tick(object sender, EventArgs e) { //清空畫面，否則前一次的畫面會保留在上面  backGraphics.Clear(Color.White); x+=1; backGraphics.DrawEllipse(Pens.Blue, x, y, 50, 50); //將backBmp上的圖畫到Form上  this.CreateGraphics().DrawImageUnscaled(backBmp, 0, 0); } ","date":"2018-03-21T10:48:34+08:00","image":"https://davidhsu666.com/archives/doublebuffer/img/doublebuffering-wiki.jpg","permalink":"https://davidhsu666.com/archives/doublebuffer/","title":"Doublebuffer雙重緩衝"},{"content":"快速判斷N是否為2的次方數 前陣子遇到一個題目 : 請你判斷一個正整數N是否為2的次方。\n我遇到這題目時，直覺想到的就是，透過迴圈從1開始檢查所有2的次方數，像這樣 :\nbool isPowerBy2_(int n) { for (int i = 1; i \u0026lt;= n; i *= 2) if (i == n) return true; return false; } // output: // isPowerBy2(1) =\u0026gt; true // isPowerBy2(2) =\u0026gt; true // isPowerBy2(4) =\u0026gt; true // isPowerBy2(-1) =\u0026gt; false // isPowerBy2(0) =\u0026gt; false // isPowerBy2(3) =\u0026gt; false 雖然這樣就解決了，但我一直在想是否有效率更高的方法。\n我們先來觀察2的次方數轉成2進制的樣子 :\n1 =\u0026gt; 0000 0001 , 1 – 1 =\u0026gt; 0000 0000 2 =\u0026gt; 0000 0010 , 2 – 1 =\u0026gt; 0000 0001 4 =\u0026gt; 0000 0100 , 4 – 1 =\u0026gt; 0000 0011 8 =\u0026gt; 0000 1000 , 8 – 1 =\u0026gt; 0000 0111 16 =\u0026gt; 0001 0000 , 16 – 1 =\u0026gt; 0000 1111 32 =\u0026gt; 0010 0000 , 32 – 1 =\u0026gt; 0001 1111 可以發現，只要該數是2的次方時，除了MSB(最高位元)是 1 其餘都是0，\n然後我們又可以發現，2的次方數減1後，剛好等於原數NOT後的值。\n在數位邏輯中 N \u0026amp; !N = 0，我們可以透過這個方法來判斷N是否為2的次方，所以是否為2的次方的判斷規則就是 :\nN \u0026amp; (N-1) == 0\n在數學中0不是任何人的次方，但這裡會有個小問題，當我們把0帶入後照樣會得到true，因為0不管和誰做AND都是0，所以要再加上一個 n \u0026gt; 0來塞選。\n最後我們得到\nbool isPowerBy2(int n) { return n \u0026gt; 0 \u0026amp;\u0026amp; (n \u0026amp; n - 1) == 0; } // output: // isPowerBy2(1) =\u0026gt; true // isPowerBy2(2) =\u0026gt; true // isPowerBy2(4) =\u0026gt; true // isPowerBy2(-1) =\u0026gt; false // isPowerBy2(0) =\u0026gt; false // isPowerBy2(3) =\u0026gt; false 那為什麼只要 n \u0026amp; n-1 == 0就代表是2的次方數呢?\n根據上面列出的幾個數字，得出如果該數是2的次方數，就只有MSB為1，而其餘數字都會有2個以上的1，所以在減1時，就不會跟MSB借位，也就沒辦法達到NOT的效果。\n7 = 0111, 7 – 1 = 0110 =\u0026gt; 7 \u0026amp; (7-1) = 110, 110 != 0\n沒辦法達到NOT效果的話，在做AND運算時就不會得到0，只有在該數為2的次方數時，AND的結果才會是零，最後就能透過結果是否為0來判斷N是不是2的次方數了\n","date":"2018-03-21T09:31:46+08:00","permalink":"https://davidhsu666.com/archives/ispowerby2/","title":"快速判斷N是否為2的次方數"},{"content":"這裡是第一篇文章的測試 相簿測試\n Photo1   Photo2   Photo1   Photo2 \n Photo1   Photo2 \n \ncode test\nstd::cout \u0026lt;\u0026lt; \u0026#34;hello world\u0026#34;; ","date":"2015-04-19T03:35:50+08:00","image":"https://davidhsu666.com/archives/just-test/original.gif","permalink":"https://davidhsu666.com/archives/just-test/","title":"JustTest"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code    Code Blocks Code block with backticks \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Fruit  Apple Orange Banana   Dairy  Milk Cheese    Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","date":"2015-03-11T00:00:00Z","image":"https://davidhsu666.com/archives/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://davidhsu666.com/archives/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\n Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so:  {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }}  To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files  Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2015-03-08T00:00:00Z","permalink":"https://davidhsu666.com/archives/math-typesetting/","title":"Math Typesetting"}]