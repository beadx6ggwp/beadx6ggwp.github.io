[{"content":"遊戲中的碰撞檢測Collision Detection \r目錄\r 1. 矩形碰撞檢測 2. 什麼是分離軸檢測? 3. 知識補充1–向量 4. 知識補充2–旋轉變換 5. 如何取得分離軸上的投影? 6. 編寫程式碼-投影、旋轉與判斷 7. 如何取得分離軸? 8. 粗糙的矩形檢測 9. 編寫程式碼–多邊形與多邊形 10. 編寫程式碼–多邊形與圓 11. SAT的總結 12. 多物體的碰撞優化 13. 動態物體間的碰撞檢測 14. Source Code 15. 結尾感想 參考資源:  \r\r\r而這篇文有三個主要目的 :\n 對遊戲中的碰撞感興趣，卻不會寫程式的人可以了解原理 讓有能力實作的人，可以跟著文章寫出精確的多邊形碰撞檢測 自己的學習筆記  讓我們開始吧。\n這次要來介紹的主題是分離軸碰撞檢測(Separating Axis Theorem, SAT)\n分離軸定理通常用語檢測兩個多邊形或多邊形與圓之間的碰撞，跟所有演算法一樣他具有一定的優勢與缺點。\n我會慢慢講解背後的原理，並使用程式碼做簡易的範例。\n範例所使用的語言為Java Script，加上自製的向量函式庫，但我想觀念懂了應該不會有太大問題。\n1. 矩形碰撞檢測 我想先從最簡單的碰撞檢測開始講，這樣比較好讓各位了解為什麼需要分離軸檢測，所以先從一般的矩形碰撞開始。\nAABB碰撞檢測(Axis-aligned Bounding Box): 為了方邊物體之間進行碰撞檢測運算，通常會對物體創建一個長方形將其包圍，AABB包圍盒也被稱為軸對齊包圍盒。\n一般二維的AABB包圍盒具備兩項特點:\n 以矩形包圍物體 矩形的每條邊，皆與坐標系的軸垂直  簡單來說就是用矩形把物體包起來，檢查矩形之間是否發生碰撞\n如下圖，黑框及為包圍盒，在做碰撞檢測時，只需要檢查包圍盒之間是否發生碰撞:\n AABB碰撞盒中的物體 \n那我們就直接來看看AABB碰撞盒是如何運作的吧。\n這裡有兩個矩形A、B，Box A最小邊為A.min、最大邊為A.max，而Box B同理。\n A.max \u0026lt; B.min \n如上圖所示，當A.max \u0026lt; B.min時，代表兩物體之間仍有縫隙，沒有發生碰撞。\n A.max \u0026gt; B.min \n上圖可以明顯地看到A與B發生碰撞，當A.max \u0026gt; B.min時，代表兩物體之間沒有縫隙，發生碰撞。\n B.max \u0026gt; A.min \n但前面只討論B在A右側，當B在A的左側時，條件就要稍微改一下，當B在A的左側時，B.max \u0026gt; A.min時發生碰撞。\n將兩張圖的結果合在一起，整理成code:\nif (A.max \u0026gt; B.min \u0026amp;\u0026amp; B.max \u0026gt; A.min) Console.log(\u0026#34;Collided\u0026#34;); 為什麼使用 AND 來判斷?\n只要A在B的右邊，那麼A.max就會永遠大於B.min，因為A.max \u0026gt; B.min是用在A在左邊的碰撞判斷，所以只要沒有發生碰撞，就代表只有一個條件會是True，碰撞無法成立，所以使用 AND。\n那麼當A在B的上面或下面呢?\n 複合情況 \n方法是一樣，對Y軸上的min、max判斷即可。\n讓我們對著圖片來看程式碼 :\nfunction RectCollision(r1, r2) { // 這邊因為(X,Y)在方塊中心，所以在取得min、max時，要 +/- width/2  // Rect1  var minX1 = r1.x - r1.width / 2, maxX1 = r1.x + r1.width / 2, minY1 = r1.y - r1.height / 2, maxY1 = r1.y + r1.height / 2; // Rect2  var minX2 = r2.x - r2.width / 2, maxX2 = r2.x + r2.width / 2, minY2 = r2.y - r2.height / 2, maxY2 = r2.y + r2.height / 2; if (maxX1 \u0026gt; minX2 \u0026amp;\u0026amp; maxX2 \u0026gt; minX1 \u0026amp;\u0026amp; maxY1 \u0026gt; minY2 \u0026amp;\u0026amp; maxY2 \u0026gt; minY1) { return true; } else return false; } // 完整原始碼在結尾與感想的最後。 測試結果:  矩形AABB結果 \n那麼另外一種情況如何?  出現旋轉的情況  如上圖，我們能明顯的看出兩物體沒有發生碰撞，但是用AABB碰撞檢測，答案卻是…發生碰撞。\nAABB碰撞檢測算法雖然計算方法簡單、速度快，但卻有幾個問題:\n 當物體旋轉時就無法檢查 只能檢查矩型物體  那麼要如何解決這兩個問題呢?\n就是本文的主題「SAT碰撞檢測」，這個方法可以完美的解決這兩個問題。\n讓我們進入下一階段。\n2. 什麼是分離軸檢測? 如果有兩個凸多邊形，在任意角度下的投影皆有重疊，代表物體發生碰撞，否則只要有縫隙，就代表沒有碰撞。\n 投影之間有縫隙 \n簡單來說，就是如果能在兩個物體間找到一條線來分離它們，那麼就代表這兩個物體之間沒有發生碰撞。\n 常見狀況 \n上圖中你可以看到第一排的物體之間有縫隙，所以能夠輕鬆地畫出一條線來分離它們，但第二排就沒辦法，因為這兩個物體已經相撞，之間沒有縫隙，所以找不出一條線來當分離線。\n而分離線不只一條 :\n 沒有發生碰撞的物體之間，有無限多分離線 \n到目前為止已經大概了解什麼是分離線，那要如何利用分離線來做碰撞檢測? 很簡單，只要檢查兩物體之間是否存在分離線即可，因為只要找到一條分離線就代表物體之間有縫隙，表示沒有發生碰撞。\n 分離軸與分離線 \n而所謂的分離軸就是與分離線垂直的一條線，透過分離軸上物體的投影是否重疊，來判斷是否發生碰撞。\n所以我們能透過分離軸檢查旋轉的物體。\n 物體在P向量上的投影 \n假設向量P是45度的延長線，由上圖可知，如果我們將A、B的「四個角投影在P向量上」，可以得到它們的min、max，接下來就能透過min、max來判斷碰撞。\n這時應該會有幾個問題:\n 如何取得分離軸上的投影min、max? 如何取得分離軸P?  但是在解決那兩個問題前，先來看看前面這段話「四個角投影在P向量上」:\n 要如何取得旋轉後的4個角? 要如何計算其中一個角落在P向量上的投影?  所以在前往下一個階段之前，要先補充一些數學的知識。\n3. 知識補充1–向量 知識補充1與2這兩段，可以先跳過，不影響閱讀，等到有看不懂的地方再回來看也行。\n為了解釋如何取得投影與分離軸，所以需要先補充向量的知識。\n數學向量忘記的話，這裡推薦幾部教學影片:\n南投高中數學課 : 向量內積公式說明、單位向量的說明\nQ仔高中數學教室 : 向量的內積、向量內積的幾何意義與座標表示法\n向量的內積:  A與B的內積 \n我們可以透過兩向量之間的夾角來計算點積: $$ A\\cdot B=\\left | A \\right |\\left | B \\right |cos \\theta $$ 或使用座標來計算: $$ \\vec{A}\\cdot \\vec{B}=A_{x}B_{x}+A_{y}B_{y} $$ 有了這兩個公式後，就可以開始來證明文章需要的公式了\n正射影 :  A在B上的投影  $$ A\\cdot B=\\left | A \\right |\\left | B \\right |cos \\theta $$ $$ cos \\theta = \\frac{A\\cdot B}{\\left | \\vec{A} \\right |\\left | \\vec{B} \\right |}=\\frac{\\left |\\vec{P} \\right |}{\\left |\\vec{A} \\right |} $$ 然後我們就會得到向量P的長度 $$ \\left |\\vec{P} \\right |=\\frac{(\\vec{A} \\cdot \\vec{B})\\left |\\vec{A} \\right |}{\\left |\\vec{A} \\right |\\left |\\vec{B} \\right |}=\\frac{\\vec{A}\\cdot \\vec{B}}{\\left |\\vec{B} \\right |} $$ 但這裡求出的P是長度(正射影長)，只有大小，沒有方向\n回到上圖可以觀察出P向量的方向是延著B向量，所以只要讓 純量P 乘上 單位向量B，就能得到A在B上的正射影。 $$ \\vec{P} = \\frac{\\vec{A} \\cdot \\vec{B}}{\\left | \\vec{B} \\right |}\\ast \\frac{\\vec{B}}{\\left | \\vec{B} \\right |}=\\frac{(\\vec{A} \\cdot \\vec{B})\\vec{B}}{\\left | \\vec{B} \\right |^{2}} $$\n所謂的單位向量就是大小為1的方向向量，而純量只有大小，兩個相乘即可得到長度為P且方向為B的向量 (如果還是不太懂的話可以自己畫圖證明看看)。\n所以正射影是A向量在B向量上的分量。\n了解正射影後，就能取得物體在分離軸上的投影了。\n法向量 : 定義:垂直於平面的向量。\n$$ \\vec{A}\\cdot \\vec{B}=A_{x}B_{x}+A_{y}B_{y} $$\n從點積公式可以得出，當兩向量垂直時，向量內積會是零。\n假設A向量為(3, 4)，求A的法向量，那麼我們只要將A帶進去，並湊一個能滿足等式為零的參數就是法向量。\n$$ (3)(B_{x}) + (4)(B_{y}) = 0 $$\n這時B向量會有無限多組合，但是有其中兩組(4, -3)、(-4, 3)，剛好就是A向量的座標互換並加負號。\n所以我們可以得到下圖結果:  向量P的左/右法向量 \n了解如何取得法向量後，就能取得需要檢查的分離軸了。\n有了向量、內積、正射影長、法向量這些基本資訊後，先來建立一個簡易的向量函式庫吧\nfunction Vector(x, y) { this.x = x; this.y = y; } // 取得這個自己的長度 Vector.prototype.length = function () { return Math.sqrt(this.x * this.x + this.y * this.y); } // 取得自己與vec2的內積 Vector.prototype.dot = function (vec2) { return this.x * vec2.x + this.y * vec2.y; } // 取得自己在vec2上的正射影長 Vector.prototype.projectLengthOnto = function (vec2) { var dotProduct = this.dot(vec2); var len = vec2.length(); return dotProduct / len; } // 取得自己的左法向量 Vector.prototype.normalL = function () { return new Vector(-this.y, this.x); } // 取得自己的右法向量 Vector.prototype.normalR = function () { return new Vector(this.y, -this.x); } 使用方式:\nvar vec1 = new Vector(3, 4);// 建立vec1向量 var vec2 = new Vector(1, 0);// 建立vec2向量 vec1.length() // =\u0026gt; 5 vec1.dot(vec2) // =\u0026gt; 3 vec1.projectLengthOnto(vec2) // =\u0026gt;3 vec1.normalL() // = (-4, 3) vec1.normalR() // = (4, -3) 4. 知識補充2–旋轉變換 為了解釋如何取得物體旋轉後的角落，所以需要先補充旋轉變換的知識。\n其作用為以原點為中心旋轉θ角:  將P繞著O旋轉θ角至P' \n如上圖，座標平面上$L = \\overline{OP}$ 且點$P(x_{1}, y_{1})$滿足$x_{1} = L*\\cos \\alpha, y_{1} = L*\\sin \\alpha$\n那麼，以原點O為中心，將這個點以逆時針旋轉 $\\theta$角後得到${P}'(x_{2}, y_{2})$\n方法一:\n先取得$\\overline{OP}$與$\\alpha$，那麼${P}'$就是$( L*\\cos (\\alpha +\\theta ), L*\\sin (\\alpha +\\theta ) )$\n但在電腦中取得OP長要透過畢氏定理開根號來取得，加上只有P點不知道α角的時候，要用Math.atan2(y, x)先取得α的角度後再計算，比較麻煩。\n所以有一個改良版:  透過和角公式改良 \n和角公式:\n$$ \\begin{cases} \\cos(\\alpha+\\theta )= \\cos \\alpha \\cos \\theta - \\sin \\alpha \\sin \\theta \\\\ \\sin(\\alpha+\\theta ) = \\sin \\alpha\\cos \\theta + \\cos \\alpha\\sin \\theta \\end{cases} $$\n所以\n$$ \\begin{cases} \\cos(\\alpha+\\theta ) = \\frac{x_{2}}{L} = \\frac{x_{1}}{L}\\times \\cos\\theta - \\frac{y_{1}}{L} \\times \\sin\\theta \\\\ \\sin(\\alpha+\\theta ) = \\frac{y_{2}}{L} = \\frac{y_{1}}{L}\\times \\cos\\theta - \\frac{x_{1}}{L} \\times \\sin\\theta \\end{cases} $$\n同乘L後即可得到 $$ \\begin{cases} x_{2}= x_{1}\\cos \\theta-y_{1} \\sin\\theta \\\\ y_{2}= y_{1}\\cos \\theta+x_{1} \\sin\\theta \\end{cases} $$\n而這個就是我們要的旋轉公式\n矩陣表示法:\n$$ \\begin{bmatrix} x_{2} \\\\ y_{2} \\end{bmatrix} = \\begin{bmatrix}\\cos \\theta \u0026amp; - \\sin \\theta \\\\ \\sin \\theta \u0026amp; \\cos \\theta \\end{bmatrix}\\begin{bmatrix} x_{1} \\\\ y_{1} \\end{bmatrix} $$\n而這矩陣就是所謂的旋轉矩陣，未來電腦圖學會很常用到。\n講解完後，把這段公式加入我們的向量函式庫吧。\nangle為弧度，並以原點(0,0)為中心旋轉angle角:\nVector.prototype.rotate = function (angle) { var new_x = (this.x * Math.cos(angle)) - (this.y * Math.sin(angle)); var new_y = (this.x * Math.sin(angle)) + (this.y * Math.cos(angle)); this.x = new_x; this.y = new_y; } 5. 如何取得分離軸上的投影? 有了投影公式後，接下來只要把A、B的四個角投影在P向量上就能知道min、max了。\n \n這時卻出現了一個狀況，如果兩個物體方向不一樣呢?\n \n由上圖可知，當兩物體方向不同時，只要在4個角落中選一個最小和最大的，就是min、max。\n那我們要如何透過投影來判斷碰撞?\n \n由上圖可以看到，A.max、B.min在P向量上的投影圖。\n當B.min \u0026gt; A.max時，代表他們之間有分離線，所以沒有碰撞。當位置交換時，A.min \u0026gt; B.max時代表有間距。\n讓我們把結果整理成code :\nif (B.min \u0026gt; A.max || A.min \u0026gt; B.max) Console.log(\u0026#34;分離\u0026#34;);// isSeparated else Console.log(\u0026#34;碰撞\u0026#34;);// isCollided 這邊選擇True為分離是因為這是分離軸檢測，我認為這樣比較符合。\n了解如何取得min、max，並如何判斷後，就可以進入下個階段了。\n6. 編寫程式碼-投影、旋轉與判斷 第一步，我們需要取得矩形上的四個角，這時就需要前面的「知識補充2-旋轉變換」\n 不如預期的旋轉 \n如果直接將四個角套用旋轉公式的話，就會像左圖一樣，物體繞中心旋轉。\n但我們想要的是右圖中，物體原地旋轉的效果，所以要將旋轉公式做點更動。\n 先平移旋轉後再平移 \n如上圖的步驟，我們需要的旋轉是以矩形中心為參考點做旋轉，而原公式以原點做旋轉，所以需要先將物體平移到原點，旋轉完後再將其平移回來。\n 正確的繞中心旋轉 \n$$ \\begin{cases} x_{1}' = [(x_{1}-x_{0})\\cos\\theta-(y_{1}-y_{0})\\sin\\theta] + x_{0} \\\\ y_{1}' = [(y_{1}-y_{0})\\cos\\theta+(x_{1}-x_{0})\\sin\\theta] + y_{0} \\end{cases} $$\n把這個公式加入向量函式庫:\n// angle:弧度, refP:參考點 // 作用: 以refP為參考點，旋轉angle角 Vector.prototype.rotateRefPoint = function (angle, refP) { let new_x = (this.x - refP.x) * Math.cos(angle) - (this.y - refP.y) * Math.sin(angle) + refP.x; let new_y = (this.y - refP.y) * Math.cos(angle) + (this.x - refP.x) * Math.sin(angle) + refP.y; this.x = new_x; this.y = new_y; } 然後讓我們來建立一個基本的物體:\n先簡單寫出Box的結構\nfunction Box(x, y, w, h) { this.pos = new Vector(x, y);// 中心  this.w = w; this.h = h; // 以順時針紀錄矩形的四個角  this.corners = [ new Vector(w / 2, -h / 2), new Vector(w / 2, h / 2), new Vector(-w / 2, h / 2), new Vector(-w / 2, -h / 2) ]; // 假設角度是45  this.directionAngle = toRadio(45);// 將45換成弧度  this.getVertices = function () { var vertices = []; // 順時針走訪角落  for (var i = 0; i \u0026lt; this.corners.length; i++) { var p1 = this.corners[i]; var vec = new Vector(this.pos.x + p1.x, this.pos.y + p1.y); // 將各個角以物體中心為參考點來旋轉  vec.rotateRefPoint(this.directionAngle, this.pos); vertices.push(vec); } // 最後回傳以物體中心為參考點選轉後的角落  return vertices; } } 接下來只要呼叫getVertices()就能取得旋轉後四個角的陣列了 :\n// 取得box1的4個角 var boxA_Vertices = boxA.getVertices(); 第二步，參考\u0026quot;如何取得分離軸上的投影\u0026quot;的說明，取得box1在分離軸上的min、max投影。而box2也是一樣的方法 :\n// 假設分離軸為45度角 var axis = new Vector(1, -1); // 取得box1的4個角 var boxA_Vertices = box1.getVertices(); // 先以第一個角當初始值 // vec.projectLengthOnto(axis) : 取得vec在axis上的投影長 var min_proj_boxA = boxA_Vertices[0].projectLengthOnto(axis); var min_index_boxA = 0; var max_proj_boxA = boxA_Vertices[0].projectLengthOnto(axis); var max_index_boxA = 0; // 再從剩下的3個角選出最大和最小投影 for (var i = 1; i \u0026lt; 4; i++) { var current = boxA_Vertices[i].projectLengthOnto(axis); // 選擇最小投影  if (current \u0026lt; min) { min_proj_boxA = current; min_index_boxA = i; } // 選擇最大投影  if (current \u0026gt; max) { max_proj_boxA = current; max_index_boxA = i; } }  \n最後，當我們有了box1和box2的min、max後，就可以檢查他們是否在axis這個軸上碰撞\nif (min_proj_boxB \u0026gt; max_proj_boxA || min_proj_boxA \u0026gt; max_proj_boxB) Console.log(\u0026#34;分離\u0026#34;);// isSeparated else Console.log(\u0026#34;碰撞\u0026#34;);// isCollided 讓我們把剛剛\u0026quot;第二步\u0026quot;的min、max取得整理一下，變成可呼叫的方法:\n// getMinMax(頂點陣列,分離軸) function getMinMax(vertices, axis) { // 先以第一個角落投影為標準  var min_DotProduct = vertices[0].projectLengthOnto(axis), max_DotProduct = vertices[0].projectLengthOnto(axis); for (var i = 1; i \u0026lt; vertices.length; i++) { // 取得當前要比對的投影長度  var temp = vertices[i].projectLengthOnto(axis); // 如果比當前最小的更小，紀錄它  if (temp \u0026lt; min_DotProduct) { min_DotProduct = temp; min_index = i; } // 如果比當前最小的更大，紀錄它  if (temp \u0026gt; max_DotProduct) { max_DotProduct = temp; max_index = i; } } var result = { min: min_DotProduct, max: max_DotProduct }; // 最後傳回一個物件包含min、max屬性  return result; } 7. 如何取得分離軸? 在SAT介紹的時候也提到，兩物體間有無限多條分離軸，難不成要真的從0度~360度的分離軸全部投影一變嗎?\n其實不需要，我們只需要沿著物體所有邊上的法向量當作分離軸作檢查，即可判斷。\n \n由上圖可知，如果我們將三角形向左平移，直到與五角形投影重疊時，代表他們發生碰撞。\n而綠色那條分離線，可以當作五角形守備的領域，只要有東西進到這裡，就代表碰撞。\n 五角形需要的分離軸為綠色虛線 \n如上圖，將五角形每個邊上的檢查線都畫出來後，只要取跟檢查線垂直的軸，就是我們需要的分離軸。\n只要有任何物體進入綠色分離線的包圍區，就代表物體與五角形發生碰撞。\n那麼要如何取得邊上的法向量?\n這時候就是補充知識1-法向量派上用場的時候了。\n 正方形的邊法向量 \n如上圖，對每個邊向量取法向量即可，而我這邊以順時針、取左法向量為例子。\n可以發現，在矩形中會有兩組方向相反的法向量，所以可以透過優化找出重複的法向量增加效率，但通常只對矩形有效果。\n先讓讓我們在Box物件中再加入getNorms()這個方法 :\nfunction Box(x, y, w, h) { // ...省略...  this.getNorms = function () { var vertices = this.getVertices();// 取得頂點  var norms = []; var p1, p2, n; // 順時鐘  for (let i = 1; i \u0026lt; vertices.length; i++) { p1 = vertices[i - 1]; p2 = vertices[i]; // 取得這個邊的左法向量  n = new Vector(p2.x - p1.x, p2.y - p1.y).normalL(); // 加入這個法向量  norms.push(n); } // 補上最後一個邊  p1 = vertices[vertices.length - 1]; p2 = vertices[0]; n = new Vector(p2.x - p1.x, p2.y - p1.y).normalL(); norms.push(n); // 最後傳回這個物體所有邊上的左法向量  return norms; } } 有了頂點取得的方式、投影大小的判斷加上邊上法向量的取得，我相信你已經有足夠的知識來完成SAT碰撞檢測了。\n8. 粗糙的矩形檢測 讓我們來看看針對矩形的程式碼，這段程式碼單純是了解檢查過程，如果你對判斷的方法不是很清楚的話希望你花一些時間看一下，後面會在寫出一個整理過的寫法。\n 實際應用在旋轉中的矩形 \n這裡我假設A方塊的法向量是P、Q，B方塊的法向量是S、R，手動對它們一一檢查\nfunction SAT_Collision(boxA, boxB) { var vertices_boxA = boxA.getVertices(); var vertices_boxB = boxB.getVertices(); var norms_boxA = boxA.getNorm(); var norms_boxB = boxB.getNorm(); // 假設boxA的法向量為P、Q，boxB為R、S  // boxA、boxB在P、Q檢查軸上的投影  var MinMax_PA = getMinMax(vertices_boxA, norms_boxA[0]); var MinMax_PB = getMinMax(vertices_boxB, norms_boxA[0]); var MinMax_QA = getMinMax(vertices_boxA, norms_boxA[1]); var MinMax_QB = getMinMax(vertices_boxB, norms_boxA[1]); // boxA、boxB在R、S檢查軸上的投影  var MinMax_RA = getMinMax(vertices_boxA, norms_boxB[0]); var MinMax_RB = getMinMax(vertices_boxB, norms_boxB[0]); var MinMax_SA = getMinMax(vertices_boxA, norms_boxB[1]); var MinMax_SB = getMinMax(vertices_boxB, norms_boxB[1]); // 在分離軸上是否分離  var separate_P = MinMax_PB.min_proj \u0026gt; MinMax_PA.max_proj || MinMax_PA.min_proj \u0026gt; MinMax_PB.max_proj; var separate_Q = MinMax_QB.min_proj \u0026gt; MinMax_QA.max_proj || MinMax_QA.min_proj \u0026gt; MinMax_QB.max_proj; var separate_R = MinMax_RB.min_proj \u0026gt; MinMax_RA.max_proj || MinMax_RA.min_proj \u0026gt; MinMax_RB.max_proj; var separate_S = MinMax_SB.min_proj \u0026gt; MinMax_SA.max_proj || MinMax_SA.min_proj \u0026gt; MinMax_SB.max_proj; var isSeparated = separate_P || separate_Q || separate_R || separate_S; if(isSeparated) Console.log(\u0026#34;分離\u0026#34;);// isSeparated  else Console.log(\u0026#34;碰撞\u0026#34;);// isCollided } 測試結果:\n 兩個旋轉矩形的碰撞檢測 \n但上面那個只適用在矩形上，而且Code又醜又長，所以把它整理一下。\n9. 編寫程式碼–多邊形與多邊形 雖然這裡的寫法也還是沒有完全優化，其實你可以將normal_polygonA、B合併後在一起走訪，但我想範例這樣比較容易了解。\n// true:兩物體分離, false:兩物體碰撞 function SAT_Collision(polygonA, polygonB) { // 取得多邊形每個邊上的法向量，回傳陣列  var normal_polygonA = polygonA.getNorm(), normal_polygonB = polygonB.getNorm(); // 取得多邊形的頂點陣列，回傳陣列  var vertices_polygonA = polygonA.getVertices(), vertices_polygonB = polygonB.getVertices(); var isSeparated = false; // 透過迴圈走訪多邊形A的法向量，來檢查是否分離  for (var i = 0; i \u0026lt; normal_polygonA.length; i++) { var minMax_A = getMinMax(vertices_polygonA, normal_polygonA[i]); var minMax_B = getMinMax(vertices_polygonB, normal_polygonA[i]); isSeparated = (minMax_B.min \u0026gt; minMax_A.max || minMax_A.min \u0026gt; minMax_B.max); // 只要發現有一條分離線，就代表物體沒有發生碰撞  if (isSeparated) return true; } // 透過迴圈走訪多邊形B的法向量，來檢查是否分離  for (let i = 0; i \u0026lt; normal_polygonB.length; i++) { var minMax_A = getMinMax(vertices_polygonA, normal_polygonB[i]); var minMax_B = getMinMax(vertices_polygonB, normal_polygonB[i]); isSeparated = (minMax_B.min \u0026gt; minMax_A.max || minMax_A.min \u0026gt; minMax_B.max); if (isSeparated) return true; } // 如果所有法向量都檢查過後，沒有發現分離，代表兩物體碰撞  return false; } 由Code可以看到，只要物體間有分離，就可以跳出並回傳結果，不需要再去檢查B的法向量。\n要注意這邊的isSeparated在分離時為Ture、碰撞時為False，如果你要以碰撞作檢查的話記得加上NOT。\n使用範例:\nfunction update(dt) { polygonA.update(dt); polygonB.update(dt); var isCollided = !SAT_Collision(polygonA, polygonB); if(isCollided){ // ...發生碰撞後要做的事...  } } 測試結果:\n   \n原始碼在最後。\n10. 編寫程式碼–多邊形與圓 已經完成範例，但還沒編寫文章\n假設今天是N多邊形與圓形，大致的做法就是，一樣取得多邊形的法向量做分離軸檢測，然後最後再多補上一條分離軸，為圓心到多邊形最近的頂點，這樣就能正確的判斷圓形。\n11. SAT的總結 關於SAT的優缺點:\n SAT的方法是些假設兩物體是分離的，並在檢查中只要成功找到正確的分離軸，就直接跳出，所以當物體都是分離狀態時，SAT的效率是非常高的。 只要物體之間有碰撞，SAT就必須檢查所有的法向量，來確保物體之間沒有分離線，越多的物體發生碰撞，效率也就越低。 因為SAT是採用所有法向量來作檢測，當多邊形的邊越多時，效率也會越來越低，但可以透過找出正負相反的法向量來減少檢查次數。 SAT雖然無法檢查凹多邊形，但是能透過將多個凸多邊形組合成凹多邊形的形狀，來作碰撞檢測。  如上圖中的賽車，雖然它的形狀是凹邊形，但能透果右邊的方式來做精密的碰撞檢測  SAT在運算時能夠取得碰撞物體間的最小穿透量(MTV, Minimum translation vector)，所以能夠處理物體間的碰撞回饋，並進一步地達成剛體動力學的模擬。  當我們希望物體不要發生穿透時，就會需要所謂的MTV，當物體穿透時，選一個最小的穿透量，將它平移回去   所以SAT碰撞在做過效能調整後，是很好的碰撞檢測演算法，靈活度也很高，是很多物理引擎會採用的檢測法之一。\n還有另一個凸邊形的高效演算法GJK以疊代地生成單形以對兩個凸集求閔可夫斯基和，有興趣可以研究看看。\n如果對碰撞方法有興趣的話可以參考這篇:\nBullet physics engin軟體工程師-Erwin Coumans : Collision Detection for Real-Time Simulation\n其他相關資源:\n SAT (Separating Axis Theorem) 2D Collision Detection 2D polygon-based collision detection and response Video Game Physics Tutorial  12. 多物體的碰撞優化 當我們要檢查多個物體碰撞時，通常會直接對所有物體互相進行判斷，就像下面這段Code:\n基本枚舉法的Code:\n// shapes是指所有的物體陣列 function update(dt) { // ...更新物體狀態...  for (var i = 0; i \u0026lt; shapes.length; i++) { for (var j = 0; j \u0026lt; shapes.length; j++) { // 如果是同個物體就跳過  if (i == j) continue; var isCollided = !SAT_Collision(shapes[i], shapes[j]); if(isCollided){ // ...碰撞事件...  } } } } 用這種最直觀的方式檢查，時間複雜度會達到O(n!)，當場景複雜，需要檢測的物體變多後，用枚舉的方式檢測可能會導致遊戲延遲。\n其中最大的問題就是，當場景中有兩個距離非常遠的物體，遠到根本不可能發生碰撞，卻照樣對他們進行檢測，導致效能的浪費。\n簡單的介紹一個優化方法 – AABB Tree :  簡易AABB Tree \n建立ABT的方法跟建立二元樹的方法一樣，來看執行步驟:\n Step1. 把A加入樹中，作為根結點。 Step2. 把B加入樹中，判斷是否與根結點A有碰撞，如果有的話就在繼續比較子節點，如果都沒有與子節點有碰撞，就把B加入子節點後，如果與節點都沒有碰撞的話，就把A、B當作一個新區域，並生成A、B的父節點(橘色圈圈)。 Step3. 把C加入樹中，方法跟Step2一樣，最後得到上圖中的樹。  假如我要檢查A物體時，只需要檢查同在橘色區域的B物體即可。\nAABB Tree在建立時，就先把有機會碰撞的放在同一區，有了這樣的結構後，要判斷碰撞的效率就提高了，因為只需判斷與該物體同區域的物體即可，並不需要全部檢查，使得時間複雜度縮減到O(log n)。\n而其他多物體碰撞的演算法還有:\n四叉樹(Quad Trees)、八叉樹(octree)、二元分割樹(BSP tree)、kd樹、球體樹(sphere tree)、R樹(R tree)、碰撞投影、光線投影等等…，有興趣的可以在自己研究。\n13. 動態物體間的碰撞檢測 這裡為大家提供一些解決的方向，我目前知道有這種解決方法，但礙於能力不足，只研究到觀念部分。\n在我們前面講的碰撞檢測方法都只適用在靜態，什麼意思呢?\n在遊戲中做的碰撞檢測其實是以離散時間來模擬，因此在每個瞬間，物體的位置和方向是靜止的，就像快照一樣，若物體的移動速度與其相對尺寸來說不是太快的話，這種方法是可行的，事實上在許多物理引擎中，都是使用這種方法。\n但對於較小且高速的移動物體，這種方法就會失效，想像現在有個很小的物體，他每次更新時的移動幅度大於碰撞體的尺寸，就會發生「穿隧」的問題。\n 如上圖所示，細小且快速的物體移動時，其路徑可能留下縫隙，導致碰撞失效。 \n解決方法\n掃描形狀(swept shape):\n對一個物體的位置、速率與加速度取線性穿插，得到一個時間段的物體快照，再透過掃描的形狀做檢測。\n 如上圖，中間的移動量就是兩次快照間的穿隧量，而球體的掃描體變成膠囊狀，三角形的掃描體變成三角柱。   若要掃描的物體正在旋轉，也能透過線性穿插來建立掃描形狀 \n形狀掃描對動態物體來說，是一個有效的檢測技術，能保證不錯過快照之間的碰撞。\n缺點是，若物體的行進路線為曲線甚至旋轉，僅透過線性穿插計算，其結果是不準確的，所以要再根據狀況使用更精準的技術。\n其實還有很多更好的解決方案，有興趣的可以在自己研究。\n14. Source Code 執行範例:\n我的SAT碰撞執行範例 : ver0.2.1-polygon-merge\nSource Code:\n 文章中的範例Source Code: https://github.com/md9830415/Collision-Detection-article 自製的向量函式庫 : https://github.com/md9830415/JS-Vector2D SAT碰撞檢測 Code: https://github.com/beadx6ggwp/Collision-SAT  額外應用:\n 最小位移量MTV Code: https://github.com/beadx6ggwp/Collision-MTV   15. 結尾感想 那麼為什麼要對碰撞這麼刁鑽，就是為了能模擬物理效果，當碰撞的處理達到一定的程度後，就可以邁向下一個階段「剛體動力學」與「物理模擬」，讓電腦中的物體越來越接近現實，有趣吧。\n光是碰撞的處理就有這麼多複雜的技術問題，就可以了解高階遊戲開發工程師是多麼厲害的一群人了。\n為了做出更好的遊戲，還要很多東西要學，為了能有效的使用電腦資源，要學會作業系統架構、演算法、資料結構並精通程式語言，要能在螢幕中顯示各種效果、視角操控，還要學習電腦圖學、線性代數，為了處理物理模擬，還要學習古典物理、高等微積分，而這些東西到了三維空間後，又更加複雜，還有專案管理等等附加技能，加上遊戲工程師們也不斷的在進化，搞不好一輩子都學不完呢。\n 終於寫完了，這篇文中我嘗試用各種插圖來解釋一些觀念，不知不覺就打了這麼多，我Coding技巧很差，範例執行的效率可能沒有很好，但我想對這篇文想表達的內容影響不大。\n最後，感謝你的觀看，希望你在閱讀後能有些收穫。\n對這文章有任何問題，歡迎在下方留言提出意見，或是E-mail與我聯絡davidmd9830415@gmail.com。\n大概就是這樣了，掰掰。\n 首次發表時間 : 2017/8 高二升三暑假準備工科賽時製作\n參考資源:  Game Engine Architecture, Second Edition.pdf : here Video Game Physics Tutorial : here Collision Detection for Real-Time Simulation : here Collision Detection – contact generation and GPU acceleration : here Physics – Collision in 2 dimensions : here Collision Detection Using the Separating Axis Theorem : here SAT (Separating Axis Theorem) : here 2D Collision Detection : here 2D polygon-based collision detection and response : here Collision detection : here Collision resolution : here Introductory Guide to AABB Tree Collision Detection : here How to Create a Custom Physics Engine : here Vector maths – a primer for games programmers : here 平面上基本的線性變換：旋轉、鏡射、伸縮、推移 : here 二階方陣表示的線性變換 : here AABB包围盒算法,在2D碰撞检测中的实现 : here “等一下，我碰！”——常见的2D碰撞检测 : here Core HTML5 Canvas: Graphics, Animation, and Game Development  ","date":"2018-03-21T05:52:36+08:00","image":"https://davidhsu666.com/archives/gamecollisiondetection/img/SAT09.jpg","permalink":"https://davidhsu666.com/archives/gamecollisiondetection/","title":"遊戲中的碰撞檢測Collision Detection"},{"content":"Win32 \r目錄\r 1.建立entry point, WinMain() 2. 向系統註冊此視窗程式 WNDCLASS 3. 建立與顯示視窗 CreateWindow 4. 訊息監聽(Event Handler) WinProc 完整範例Code  \r\r\r參考 : MSDN Get Started with Win32 and C++\n1.建立entry point, WinMain() // int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR pCmdLine, int nCmdShow) // wWinMain為UniCode模式，WinMain為Ansi模式  int CALLBACK WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow){ // ...  return 0; } #define CALLBACK __stdcall: 簡單來說__stdcall就是專門用來call WinAPI的，詳細還有待研究\n參數:\nhInstance : windows為應用程式生成的追蹤資料，h代表handle(處理程序)\nhPrevInstance : 追蹤建立此視窗的前一個程式，但現在基本無用\nlpCmdLine : 相當於int main(int argc, char** argv)的執行時可傳入的參數列 e.g. main.exe -t -d\nnCmdShow : 為一整數，在執行時傳入來控制視窗的樣式 e.g. SW_MAXIMIZE (3)、SW_MINIMIZE (6)、SW_SHOWMINNOACTIVE (7 啟動時最小化) 等等\n 2. 向系統註冊此視窗程式 WNDCLASS WNDCLASSA structure (winuser.h)、 Window Class Styles、 RegisterClass\ntypedef struct tagWNDCLASSW { UINT style; WNDPROC lpfnWndProc; int cbClsExtra; int cbWndExtra; HINSTANCE hInstance; HICON hIcon; HCURSOR hCursor; HBRUSH hbrBackground; LPCWSTR lpszMenuName; LPCWSTR lpszClassName; } WNDCLASSW style : 不是造型的那種style，而是視窗行為模式的設定，像是CS_HREDRAW | CS_VREDRAW\nlpfnWndProc : Window事件處理的CallBack，funcPointer\ncbClsExtra、cbWndExtra : 視窗類分配的額外字節數。在大多數情況下，此成員為0。\nhInstance : 通常直接將WinMain的hinst傳過來即可，因為同一個視窗程式\nlpszMenuName : Menu ID，不需要的話NULL即可\n所以基本上只需要幾個關鍵參數:\nWCHAR cls_Name[] = L\u0026#34;Win32 Class\u0026#34;; WNDCLASS wc = { }; wc.lpfnWndProc = WindowProc; wc.lpszClassName = cls_Name; wc.hInstance = hInstance; // 並在最後向上層系統註冊此視窗類別，為什麼要註冊還有待研究 RegisterClass(\u0026amp;wc); 3. 建立與顯示視窗 CreateWindow MSDN CreateWindowExA function、 window style values\nvoid CreateWindowA( lpClassName, //類別名稱，要和剛剛一致  lpWindowName, //標題文字  dwStyle, //視窗外觀樣式 window style values  x, //相對於parent的x座標  y, //相對於parent的y座標  nWidth, //視窗寬度  nHeight, //視窗高度  hWndParent, //parent window，沒的話NULL即可  hMenu, //menu，沒的話NULL即可  hInstance, //當前程式的Hander  lpParam //附加資料，沒的話NULL即可 ); returnType HWND 使用方式: 基本上照著參數給予資料，就會執行建立視窗這個動作，並返回HWND(此視窗的handle)\nHWND hwnd = CreateWindow( cls_Name, //類別名稱，註冊與建立要是同個視窗類別  L\u0026#34;Win32 test\u0026#34;, //標題文字  WS_OVERLAPPEDWINDOW, //視窗外觀樣式  100 //相對於parent的x座標  200, //相對於parent的y座標  400, //視窗寬度  300, //視窗高度  NULL, //parent window，沒的話NULL即可  NULL, //menu  hInstance, //當前程式的追蹤  NULL); //附加資料  if (hwnd == NULL) //判斷是否成功Create  return 0; 4. 訊息監聽(Event Handler) WinProc  訊息流程 \n整個視窗程式不是單純建立而已，Windows背後會處裡很多事情，像是基本滑鼠鍵盤的IO、WM_CREATE建立時發起的事件、WM_DESTROY(在關閉視窗後釋放資源)、WM_Paint視窗繪製事件等等，所以需要透過監聽的方式持續檢查收到甚麼消息\n如果只有前面那幾段，程式會是開起來後馬上關掉，其實不是執行失敗，而是執行後馬上就結束了，像是Console中可以透過system(\u0026ldquo;pause\u0026rdquo;)或是getchar()來卡著程式直到使用者輸入，但視窗程式用戶除了鍵盤以外還有滑鼠等各種操作，如移動視窗、縮放視窗、縮小視窗等等，用getchar()會導致程式卡在這裡無法進行其他操作\n所以windows視窗程式透過無限迴圈讓程式一直不結束，只是這樣一樣甚麼事情都做不了，也無法關閉程式，這時就有了事件監聽這種設計，在必要的時候傳指令給程式，讓程式做出對應的功能，像是按下X的時候，系統會送出QUIT的事件，讓程式知道現在要關閉程式釋放資源\n而有事件監聽後，就要有地方來儲存累積起來的事件，讓程式逐一處理，而這就是訊息序列MsgQueue\ntypedef struct tagMSG { HWND hwnd; UINT message; WPARAM wParam; LPARAM lParam; DWORD time; POINT pt; } MSG, *PMSG, *LPMSG; 完整範例Code 執行方法，VS建立empte winodws專案，加入CPP檔案並把這段貼上即可\n#include \u0026lt;Windows.h\u0026gt; //LRESULT CALLBACK WindowProc(_In_ HWND hwnd, _In_ UINT uMsg, _In_ WPARAM wParam, _In_ LPARAM lParam); LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);//MSDN  // entry point //_In_opt_ SAL annotations(向編譯器詳細規範參數型態) int CALLBACK WinMain( _In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ int nCmdShow) { WCHAR cls_Name[] = L\u0026#34;Win32 Class\u0026#34;; /* 執行時此處要注意 RegisterClass(): MSDN:You must fill the structure with the appropriate class attributes before passing it to the function. 表示WNDCLASS需要完全初始化才行，如果沒有全部初始化，會導致變數無法正確的分配空間，導致註冊失敗 要不就是所有變數手動指定預設資料，但有點麻煩，所以需要 WNDCLASS wc = { sizeof(WNDCLASS) }; 再簡化就是WNDCLASS wc = { }; 補充: typedef struct rectStruct { int x; int y; int width; int height; } RECT 初始化所有資料: RECT rect = { 0, 0, 20, 30 }; 初始化所有為預設值(此為int所以為0) RECT rect = { }; */ WNDCLASS wc = { }; wc.hbrBackground = (HBRUSH)COLOR_WINDOW; wc.lpfnWndProc = WindowProc; wc.lpszClassName = cls_Name; wc.hInstance = hInstance; // 向上層註冊  RegisterClass(\u0026amp;wc); HWND hwnd = CreateWindow( cls_Name, //類別名稱，要和剛剛一致  L\u0026#34;Win32 test\u0026#34;, //標題文字  WS_OVERLAPPEDWINDOW, //視窗外觀樣式  100, //相對於parent的x座標  200, //相對於parent的y座標  800, //視窗寬度  600, //視窗高度  NULL, //parent window，沒的話NULL即可  NULL, //menu  hInstance, //當前程式的追蹤  NULL); //附加資料  if (hwnd == NULL) //判斷是否成功Create  return 0; // 顯示視窗  ShowWindow(hwnd, SW_SHOW); // 更新視窗，通常可有可無，因為只要視窗開著，WM_PAINT就會持續調用並更新視窗  //UpdateWindow(hwnd);  // 事件訊息loop  MSG msg; while (GetMessage(\u0026amp;msg, NULL, 0, 0)) { TranslateMessage(\u0026amp;msg); DispatchMessage(\u0026amp;msg); } return 0; } // callback事件處裡 function pointer LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) { switch (uMsg) { case WM_DESTROY: { PostQuitMessage(0); return 0; } } return DefWindowProc(hwnd, uMsg, wParam, lParam); } ","date":"2020-12-11T05:01:26+08:00","image":"https://davidhsu666.com/archives/win32note01/img/1602103707812.jpg","permalink":"https://davidhsu666.com/archives/win32note01/","title":"[Win32筆記] 建立視窗 #1"},{"content":"從零開始的基礎RPG框架 Sourcecode : 運行SourceCode時將此目錄丟到Apache中即可\n遊戲Demo連結 操作方式: 上下左右、空白鍵衝刺、 Z 攻擊、X 遠程、T 開啟Debug、WASD移動視角、R 重製視角\n ver01(game) : 可以讀取地圖的第一版 基礎展示(game0) : 用簡易的基礎地圖展示所有功能 上下坡事件觸發器(game2) :  透過觸發器更改人物所在圖層，正確判斷上下坡的碰撞  完整的場景(gameshow1) :  右邊兩個圓形為加速事件觸發器，碰到即可變更速度  多邊形碰撞場景(gameshow2) :  滑鼠拖曳後按左鍵發射小球，來觀看多邊形碰撞回饋   目前進度  攝影機 動態碰撞盒 事件觸發器 自訂地圖存取 Debug(圖層、碰撞層顯示)  攝影機、Debug  加入Debug功能方便測試 只顯示視線範圍內的物件 渲染物件的動態圖層顯示 可隨意設定攝影機的追蹤範圍與目標，例如視角綁定在小鳥身上   WASD控制攝影機   透過Z-index畫家排序來處理多圖層 \n碰撞盒:多邊形碰撞與回饋 http://davidhsu666.com/archives/gamecollisiondetection/\n透過分離軸定理，解決普通AABB碰撞檢測無法處裡的多邊形與圓形\n建立自製碰撞函示庫，並透過最小穿透量來處理物體間的分離，將碰撞盒整合至物體中並加以應用\n   \n動態碰撞盒、敵人移動、事件觸發器 -透過動態碰撞盒處理揮砍的動作\n-加入狀態切換管理，攻擊開始-\u0026gt;攻擊中-\u0026gt;攻擊結束\n 透過事件觸發器處理各式地圖事件 像是地圖上下坡，需要切換碰撞層，與NPC對話區域的觸發器，或是走斜坡時會被減速等等   發射劍氣   事件觸發器-加速 \n地圖編輯與讀取 透過json檔案生成對應的地圖物件，如動畫、碰撞、物件等\n依照編輯時的圖層，建立對應的顯示順序\n而每個Group相隔10的Z-index，圖中Group2、Group4分別有橋下與橋上的碰撞層，所以只要更改人物的Z-index即可實現上下區域的碰撞切換\n並支援自訂多邊形，圖中左下角的噴水池為自訂多邊形所包成的碰撞體，基礎展示(game0)中的石頭也是\n 地圖的編輯 \n大致運行方式 所有物體皆繼承自Entity :\nEntity: { name: \u0026#34;monster\u0026#34; // 此Entity的名稱或類別  pos: { x: 0, y: 0 }, vel: { x: 0, y: 0 }, acc: { x: 0, y: 0 }, zindex: 20, collider: { // 碰撞盒範圍，不規則多邊形則指定相對位置頂點  x: -15, y: -15, w: 30, h: 30 }, bounceToMap: false, // 是否與地圖發生向量鏡射的反彈回饋  collisionToMap: true, // 是否與地圖發生碰撞  world: Worldmap, // 所在的地圖  animation: { // 圖片的設置  frameWidth: 44, frameHeight: 40, renderScale: 1 / 2, imgName: \u0026#39;coin\u0026#39;, speed: 15, action: { // 設定個動作的循環  \u0026#39;default\u0026#39;: \u0026#39;0-9\u0026#39;, // 可連續設置也可跳號指定  \u0026#39;atk\u0026#39;:\u0026#39;11,12,14,19\u0026#39;, \u0026#39;imgMode\u0026#39;,\u0026#39;25\u0026#39; // 靜態圖片模式  } }, survivalMode : false, // 是否消失  survivalTime : -1, // 設定存在時間  hitActionData :{ // 事件觸發器: 設定此Endity在更新時要和誰互動的事件  target: [...], // 設定那些物體會觸發  action: (ent1, ent2) { // ent1為自己、ent2為其他entity  // 設定兩物體接觸後的處理，如碰撞分離、更改速度等等的事件觸發器  } } } 事件觸發器的使用，以地圖中的Tile與玩家/怪物的碰撞為例:\nTileEntity = { name: \u0026#39;layerObj\u0026#39;, pos: { x: 0, y: 0 }, // 設定為每塊Tile所在的位置  collisionToMap: false, hitActionData: { parent: this, // 觸發器的本體是誰  target: [\u0026#39;player\u0026#39;,\u0026#39;enemy1\u0026#39;], // 設定和player與enemy兩種Entity反應  // 對target中的物體執行對應動作  action: function (ent1, ent2) { // 取得自己與其他Entity的碰撞盒  let collider1 = ent1.getCollisionBox(); let collider2 = ent2.getCollisionBox(); // 碰撞檢測  if (!box2box(collider1.getBoundingBox(), collider2.getBoundingBox())) return; // 處理碰撞後的推擠判斷與向量鏡射  let mtv = collider1.collideWith(collider2); if (mtv.axis) { let v = separate(collider1, collider2, mtv) ent2.pos.add(v); mtvBounce(ent2, mtv) } } }, drawBase: true } 當所有物體，不管是玩家、敵人、地圖Tile等，有了這個萬用的Entity後，即可透過簡單的方式更新各自Entity的循環\n// 程式中的主循環 function update(dt, tickcount) { let entities = world.gameObjs; // 更新所有物體  for (const entity of entities) { entity.update(dt); } // 逐一檢測各Entity的事件觸發器  for (let i = entities.length - 1; i \u0026gt;= 0; i--) { let entity = entities[i]; let had = entity.hitActionData; if (!had) continue; // 此物體沒有觸發器的話就直接跳過  for (let j = entities.length - 1; j \u0026gt;= 0; j--) { let entity2 = entities[j]; // 判斷這個物體是否在觸發器的目標中  if (had.target.indexOf(\u0026#39;ALL\u0026#39;) != -1 || had.target.indexOf(entity2.name) != -1) { // 執行觸發器對應的處理  had.action(entity, entity2); } } } // 檢測那些物體該被移除  for (let i = entities.length - 1; i \u0026gt;= 0; i--) { const entity = entities[i]; if (entity.isDead) entities.splice(i, 1); } // camera.follow(dt, player);  cameraControl();// 更新攝影機位置 } 碰撞效能的優化 Quadtree_in_2d\n如果每個物體之間都進行碰撞檢測，會消耗大量的效能，複雜度來到O(N^2)\n例如: 兩物體在地圖的對角線，根本不會碰撞，但還是執行檢測\n透過四叉樹(Quad Tree)來進行空間上的劃分\n將複雜度降低至O(N log(N))\n   \n架構與後續規劃  UI選單、Menu、功能列操作 對話方塊與對話事件(對話樹) 腳本編輯與腳本觸發器，如RPG遊戲中的串場事件 優化物件架構，方便修改   簡易架構圖 \n檔案架構 ├─asset │ ├─data │ ├─img │ ├─sound │ └─tile │ │ Camera.js │ Collision.js │ Enemy.js │ Entity.js │ index.html │ main.js │ Particle.js │ Player.js │ player2.js │ Setting.js │ Shape.js │ Tilemap.js │ └─lib AssetLoader.js drawString.js Game.js SpriteAnimation.js stats.min.js utils.js vec.js 參考資料 https://gablaxian.com/articles/creating-a-game-with-javascript/introduction http://isaacsukin.com/news/2015/01/detailed-explanation-javascript-game-loops-and-timing\n","date":"2020-12-04T02:16:07+08:00","image":"https://davidhsu666.com/archives/2dgame-nonename/img/123213487.png","permalink":"https://davidhsu666.com/archives/2dgame-nonename/","title":"從零開始的基礎RPG框架"},{"content":"工科賽-軟體設計 歷屆試題解答  \n前言: 名次不高，這篇文只是單純分享，想看高手的心得，直接Google “ACM ICPC 心得”\n我是106屆工科軟體競賽選手，覺得高職選手的資源不是很多，如果沒有老師、學長指導、沒有解答、也沒有累積相關知識技術的底，想拿前段名次會辛苦很多。\n先簡單講講，所以可能有點亂，主要是該寫甚麼我也不清楚，工科軟體跟TOI比起來，知名度跟難度都差滿多的，所以也沒什麼人在關注或是討論題目，資源自然就少，大多只能靠學長或老師傳承解答。\n高職的比賽，沒興趣不太建議靠比賽升學，做選手學東西就行，因為沒有很好的名次加上備審，不好上前段國立，所有國立科大資工開放的總名額大概只有30個左右，採計的比賽也不只工科賽，所以就算前15名也不見得能上國立。\n全國工科技藝競賽 軟體設計在比什麼: 簡單來講就是用程式邏輯來解各種應用問題，但比UVA、IOI簡單，比較偏向應用一些吧，可以翻下面的題庫來看看在比什麼。 像是8-Puzzl轉盤，要在解題的時候去思考，如何讓電腦找到最少步數，相比傳統解題競賽，較著重在功能呈現上。\n BFS解8-Puzzle \n相關文章: 用BFS解8-Puzzle問題\n準備方式: 語言建議用C#(至少要會哪些之後再補好了)。\n建議是在暑假的時候先看完一到兩本演算法或資料結構的書(推薦啊哈!圖解演算法、大話資料結構)，每天看一個段落，理解後就實做一次，很快就能看完了，以我來說大約一個月。\n差不多開學後，開始練習工科賽題目，我是覺得工科賽歷屆題目就直接拿來計時比較實在，不然沒人幫你出題目，要想出能提升自己技術的題目內容其實挺難的，然後在11月前把工科北軟歷屆解完。\n11月前記得也要寫學科，學科這邊就不用寫太多，覺得自己的相關知識差不多後，寫工科的99~104，如果每張不看解答或查資料，都有90左右，就差不多了，建議寫完就算對了也要在旁邊補上解法，這樣到時候比賽前複習才比較方便。\n接著11月初，如果你是台北人，建議參加北軟，模擬一些臨場感，因為當你有所準備時，上場真的會很緊張，不然也沒什麼機會能模擬比賽了….。就算不是也沒關係，北軟比完會釋出題目，把它全部做完。\n接著補一些自己當初不會或是卡住的內容，花點時間研究，並給自己出模擬試題，檢查自己哪些觀念不太夠。\n如果你都完成了，就準備比賽拿金手吧。\n雜談: 要拿金手比IOI培訓營簡單很多，感覺教育部也沒特別規定高職的程式設計課程要怎麼上，就變成看學校老師個人造化的感覺。\n別校選手說他們老師也是不推薦比賽，他參賽的原因只是科排第一，被科主任盧過來的。\n全台60幾所高職報名軟體設計，真正有在訓練選手的也就那幾間，感覺其他很多都是被學校盧過來參加，或是覺得有趣隨便報名，反正校內選拔也沒人在搶，所以比賽水平自然沒有IOI那麼高。\n大概是這樣吧，我自己還有一些想法跟心得，只是不曉得怎麼寫。 剩下看要問什麼吧，一些比較深的演算法，我答不出來可以去這一串問，滿多人可以幫忙的。\n電腦修護那塊，我伺服器沒什麼研究，單晶片當初有協助同校選手，所以還算幫得上忙吧，有問題可以問問看。\n解答: 歷屆題目的程式碼，這些題目解答都是我自己寫的，雖然寫得很爛，但至少能解出題目要求的解答，所以寫法有看不懂的地方，我看一下題目跟Code都能回答。\n這邊放北軟的歷屆，主要是我覺得北軟的題型跟工科賽幾乎一樣，而且出題老師也跟工科賽有重疊，因為這幾年都有類似的題目出現，加上北軟在工科賽之前比，非常值得做參考。\n工科賽軟體設計: 歷屆題目 : Here 96~106屆參考解答 : Here\n北市軟體設計競賽(高工): 歷屆題目 : Here 99~106屆參考解答 : Here\n","date":"2019-11-06T09:38:44+08:00","image":"https://davidhsu666.com/archives/skills-competition-software/img/skill_img1.jpg","permalink":"https://davidhsu666.com/archives/skills-competition-software/","title":"工科賽-軟體設計 歷屆試題解答"},{"content":"Vector Reflection 這篇文應該是要跟MTV(Minimum Translation Vector)的碰撞回饋一起寫，但MTV發起來有點長，懶得打，先記錄Vector Reflection\n為什麼需要取得鏡射向量(Vector reflection) 一個簡單的例子，當乒乓球擊中球拍時，要如何取得反彈後的向量，而光影模擬時也會需要取得光線反射的向量，這時向量反射就非常重要了。\n因為這篇內容比較基礎，所以一些基本部份就省略了\n如何取得Vector reflection  V1打到Axis上，並反彈至V2 \n先定義一些資訊:\n V1 = 物體的速度 V2 = 物體反彈後的速度 N = 擊中平面的法向量  如何取得擊中平面的法向量 N 呢?\n很簡單，透過兩垂直向量點積為0的特性就可以得到，假設Axis是(3, 4)的向量，那平面法向量就會是(-y, x) = (-4, 3) 或是 (y, -x) = (4, -3)  左/右法向量 \n再來看如何取得 V2\n將V1與V2之間畫一條線，並組合成一個平行四邊形，這樣就很明顯得到 V2 = 2N' + V1，那麼接下來的問題就會是如何取得N'。  img \n先只單看V1跟法向量N，可以發現N' 其實就是V1在法向量N上面的投影$proj_{\\hat n}V_{1}$，所以可以透過基本三角函數來取得\n但$\\cos \\theta$需要另外計算夾角，所以有個更好的方法來代替，在點積公式中，使其中一個向量為單位向量，因為長度為1可直接省略，所以$\\left |V_{1} \\right | \\cos \\theta = V_{1} \\cdot \\hat{n}$，要加負號是因為$V1$與$\\hat{n}$為反方向，$\\left |V_{1} \\right | \\cos \\theta$會是帶負號的純量，但我們需要的$\\hat{n}$是與$V_{1}$反向的，所以加上負號:\n 法向量n可透過正規話取得 \n而$(V_{1} \\cdot \\hat{n})\\hat{n}$就是快速求得$V_{1}$在法向量$\\hat{n}$投影的方式: $$proj_{\\hat n}V_{1}=(V_{1} \\cdot \\hat{n})\\hat{n}$$\n再來回到$V_{2} = 2N' + V_{1}$\n該有的東西都有了，所以整理後可以得到:\n$$V_{2} = V_{1} - 2(V_{1} \\cdot \\hat{n})\\hat{n}$$\n V1 = 物體方向 n = 擊中平面的\u0026quot;單位\u0026quot;法向量 v2 = 反彈後的方向  接者就可以放在當物體與某個平面碰撞後，更新反彈後的速率為V2，就會有乒乓球反彈的效果了\n大概就這樣，具體結果可以參考:從零開始的基礎RPG框架\n參考資料  Basic Ad Hoc Collision Response 3D Programming Weekly:Graphics:Reflecting a Vector How to get reflection vector?  ","date":"2019-04-26T03:58:47+08:00","image":"https://davidhsu666.com/archives/math-for-game-vector-reflection/img/13fig21.gif","permalink":"https://davidhsu666.com/archives/math-for-game-vector-reflection/","title":"Vector reflection向量鏡射 基本的碰撞反彈回饋"},{"content":"碰撞檢測的優化-四叉樹(Quadtree) \r目錄\r 1. 什麼是QuadTree? 2. 插入流程: 3. 搜尋流程: 4. 實作QuadTree–插入 5. 實作QuadTree–搜尋 6. 實際應用 7. 總結 8. 參考資源  \r\r\r許多遊戲都會需要碰撞檢測來判斷兩物體的碰撞，但這些演算法通常是較為昂貴的操作，如果無法有效率的選擇檢測目標，很可能會大幅降低執行的速度。(像是之前提到的SAT碰撞檢測)\n在之前的”多邊形碰撞檢測”文中，也有提到當檢測物體越來越多時，基本逐一檢測的效率會越來越差，複雜度約為O(n^2)，就算排除重複檢測過的物體，只要是逐一檢測的方法就一定會走訪所有物件。\n \n從上圖可以得知直接全部檢測的話是4 x 5 = 20，如果扣掉重複，至少是4 + 3 + 2 + 1 = 10，但真正的問題是，就算1和3距離這麼遠，也照樣會檢查它們，那有沒有方法能解決這種狀況呢?\n這就是文章的主要內容，QuadTree。\n1. 什麼是QuadTree? 四叉樹(QuadTree)是一種劃分2D區域的樹狀資料結構，類似一般的二元樹，但子節點是4個，而不是2個。\n區域的劃分架構類似這樣 :\n 將區域分成四塊   每塊再往下劃分   加入多個物體後的效果   運行效果，點圖放大 \n並限制每個區域能容納的上限，當超過後就將該區域再往下分割4塊，這樣就能夠將每個物體進行區域分類，這樣在檢查的時候就可以鎖定部分區域的物體，從而增加效率。\n2. 插入流程: 假設我先設定每個區域只能容納4個物體，只要超過該容量，就要分割該區域。\n左圖方形區域已經有4個物體，想再加入第5個時，就必須分割成4個子區域，再將第5顆分類到最近的左上角區域中，如右圖:\n 超過容量時擴展子樹 \n以此類推，當要放入第9顆物體時，發現黑色區域也滿了，所以就再往下分割紅色區域，並放入離該物體最近的右下角區域中，如下圖:\n 此區域也超過後，繼續擴展下去 \n最後，就可以得出這樣的樹狀結構，這就是為什麼會叫做4叉樹的原因，如下圖:\n 完整流程 \n3. 搜尋流程: 給定一搜尋範圍，並逐一排除不可能的區域，最後取得搜尋範圍內的物體。\n接續前面插入的狀態，假設我要檢測綠色框框內的物體是否發生碰撞，步驟如下 :\n 與藍框區域作碰撞檢測，發現有所交集，檢測藍色區域的物體是否包含在綠框中，發現並沒有。 與藍框的黑色子區域作檢測，發現只與左上的區域有所交集，所以排除另外三個區域，並發現有2個物體包含在綠框內。 再往下檢察左上黑框的紅色子區域，並排除左上、左下，發現有3個物體在綠框內，紅框沒有子領域，走訪結束。  最後回傳搜尋到的5個物體。\n 搜尋步驟   大致流程 \n如果是碰撞檢測的應用的話，就是把綠框換成該物體周圍可能發生碰撞的範圍，再來套入搜尋，就能更加簡化碰撞檢測的流程，如下圖 :\n 給定搜索形狀 \n假設要檢查綠色圈圈與那些物體發生碰撞，透過前述的篩選流程，搜尋到最後，只要針對和綠圈區域相交的3個物體檢測就好，以此達成碰撞效率優化。\n這就是四叉樹的原理，接著進入實作環節吧。\n4. 實作QuadTree–插入 先整理大致的插入順序:\n 如果該點不屬於A區域，直接結束 如果該點屬於A區域，且A區域容量還夠的時候，將該點加入A區域 如果A區域容量不夠時，將A區域劃分4個子區域，並將該點加入離它最近的子區域  建立基本物件 :\nclass Point { constructor(x, y) { this.collisionType = \u0026#34;point\u0026#34;; this.x = x; this.y = y; } } class Rect { constructor(x, y, w, h) { this.collisionType = \u0026#34;rect\u0026#34;; this.x = x; this.y = y; this.w = w; this.h = h; } } 四個子區域的規劃:\n 定義每塊區域的範圍 \n並依照前述所說的插入順序，來建立QuadTree :\nclass QuadTree { constructor(boundary, level) { this.MAX_OBJ = 4;// 該容器最大容量  this.MAX_LEVEL = 5;// 最大深度  this.objs = [];// 該容器的物體集合  this.areas = [];// 四塊子區域  this.level = level || 1;//當前深度  this.boundary = boundary;// 容器範圍(Rect)  } /* 如果該點在範圍內，且容量也夠的話就新增該點至區域內，或是到達最大深度也直接新增 到達容量上限後，就分割出四個子領域，再將物體分類至最靠近的子領域中 */ insert(object) { // 先確認物體是否在邊界內  if (!CheckCollision(this.boundary, object)) return false; // 如果當前容量與深度未達上限，就直接新增該物體  if (this.objs.length \u0026lt; this.MAX_OBJ || this.level \u0026gt;= this.MAX_LEVEL) { this.objs.push(object); return true; } // 如果容量達上限，且沒有子領域的話，分割出四個子領域  if (this.areas.length \u0026lt;= 0) this.subdivide(); // 嘗試給子領域新增該物體  for (let area of this.areas) { if (area.insert(object)) return true; } } subdivide() { let x = this.boundary.x, y = this.boundary.y; let w = this.boundary.w, h = this.boundary.h; // 矩形以左上為基準，依照各象限順序建立子領域，並新增到areas中  this.areas.push(new QuadTree(new Rect(x + w / 2, y, w / 2, h / 2), this.level + 1));// topRight  this.areas.push(new QuadTree(new Rect(x, y, w / 2, h / 2), this.level + 1));// topLeft  this.areas.push(new QuadTree(new Rect(x, y + h / 2, w / 2, h / 2), this.level + 1));// bottomLeft  this.areas.push(new QuadTree(new Rect(x + w / 2, y + h / 2, w / 2, h / 2), this.level + 1));// bottomRight  } show(ctx) { // 繪製邊界  ctx.strokeStyle = \u0026#34;#FFF\u0026#34;; ctx.strokeRect(this.boundary.x, this.boundary.y, this.boundary.w, this.boundary.h); // 顯示物體數/容量數，Debug  drawString(ctx, this.objs.length + \u0026#34;\\n\u0026#34; + this.MAX_OBJ, this.boundary.x + this.boundary.w / 2, this.boundary.y + this.boundary.h / 2, \u0026#34;rgba(255,255,0,0.5)\u0026#34;, 10, \u0026#34;consolas\u0026#34;, 0, 0, 0); // 往下繪製所有子領域區塊  if (this.areas.length != 0) { for (let area of this.areas) { area.show(ctx); } } // 繪製出這塊領域的物體  for (let obj of this.objs) { ctx.beginPath(); ctx.arc(obj.x, obj.y, 3, 0, Math.PI * 2); ctx.stroke(); } } } 至於程式中CheckCollision(ObjectA, ObjectB)，就是單純的點與矩形的碰撞檢測，請參考結尾附上的Code。\n使用方法 :\n// 建立QuadTree var qt = new QuadTree(new Rect(0, 0, Width, Height)); // 新增物體 qt.insert(new Point(X, Y)); // 在Canvas中顯示分割與物體狀況 qt.show(Context); 如此一來就能建立基本可新增物體的QuadTree了。\n基本插入範例，滑鼠點擊即可新增物體。新視窗執行 : Here\n 然後可以看到，每當一個區域插入4個物體後(MAX_OBJ = 4)，就會將該領域往下分割4個子區域，最多分割5層(MAX_LEVEL = 5)。\n5. 實作QuadTree–搜尋 搜詢的大致順序 :\n 如果搜尋範圍跟當前領域相交，檢查該領域有多少物體包含在搜尋範圍中，並增加至陣列中 當該領域有子區域時，繼續往下檢查有多少物件包含在搜尋範圍內 直到所有搜尋範圍內的區域都被檢測過，回傳所有在搜尋範圍內的物體  可以比對一下上面講的搜尋流程，應該會更清楚。\n根據上述步驟，在QuadTree中加入query這個function :\nquery(range, found){ // 如果沒有給定回傳的陣列，就建立一個  if(!found) found = []; // 判斷搜尋範圍(range)是否與當前領域有相交，沒有就直接跳掉，以節省效率  if (!CheckCollision(this.boundary, range)) return; // 如果搜尋範圍跟當前領域相交，檢查該領域有多少物體包含在搜尋範圍中，並增加至found  for(let p of this.objs){ if (CheckCollision(p, range)){ found.push(p); } } // 當該領域有子區域時，繼續往下檢查有多少物件包含在搜尋範圍內  if(this.areas.length != 0){ for(let area of this.areas){ area.query(range, found); } } // 完成搜尋，回傳結果  return found; } 而使用方法也非常簡單，給定一個搜尋區域，接著query就會直接撈出所有在搜尋範圍內的物體了 :\n// 假設queryTree已經新增一些物體了 // 建立一個搜尋範圍 var checkRange = new Rect(20, 40, 150, 150); // 套用搜尋範圍至queryTree取得範圍內的物體 var objects = queryTree.query(checkRange); 基本搜尋範例，滑鼠點擊新增物體，移動可取得範圍內的物體。新視窗執行 : Here\n 6. 實際應用 我將正常的碰撞檢測與QuadTree檢測放在一起做比較，可以清楚的看到，當物體數量到2000時，No QuadTree的檢測方法已經無法負荷，畫面有明顯卡頓。換成QuadTree檢測後，就只掉一點FPS，透過比對，可以明顯看到效能的提升。\n每當物體碰撞時變成白色，滑鼠點擊新增100個物體，按下按鈕以切換不同檢測模式，觀察效能的差距 :\n在新視窗執行 : Here\n 7. 總結 QuadTree或許不是最好的多物體檢測法，但多數狀況下還堪用，至於QuadTree優化的部分，可以參考這篇文章，講得非常清楚。\n這邊預計要再補上QuadTree跟其他檢測法的優缺點，但目前只研究QuadTree，所以無從比較，日後補上。\n文章中所有的Source Code都在Github中 : https://github.com/md9830415/JS-QuadTree\n大概就是這樣了，下期再見，掰掰。\n8. 參考資源  Coding Challenge #98.1: Quadtree – Part 1 Quick Tip: Use Quadtrees to Detect Likely Collisions in 2D Space Efficient (and well explained) implementation of a Quadtree for 2D collision detection JavaScript QuadTree Implementation  ","date":"2018-10-27T07:31:13+08:00","image":"https://davidhsu666.com/archives/quadtree_in_2d/img/Quad_013.png","permalink":"https://davidhsu666.com/archives/quadtree_in_2d/","title":"碰撞檢測的優化-四叉樹(Quadtree)"},{"content":"JS Firework 跨年煙火  \n買不起煙火沒關西，自己模擬一個就行了。 最近剛好學會一些特效，就順便寫個簡易粒子效果，來做個跨年煙火。\n可以到此連結遊玩，使用滑鼠左鍵施放煙火 :\n連結 : Click Here\nGitHub : Click Here\nHappy new year !!! ","date":"2018-08-31T10:55:51+08:00","image":"https://davidhsu666.com/archives/js-firework-%E8%B7%A8%E5%B9%B4%E7%85%99%E7%81%AB/img/firework3.gif","permalink":"https://davidhsu666.com/archives/js-firework-%E8%B7%A8%E5%B9%B4%E7%85%99%E7%81%AB/","title":"JS Firework 跨年煙火"},{"content":"目錄  前言 儲存結構和移動判斷 用BFS窮舉狀態 執行結果 參考資源  1. 前言 先來簡單的介紹一下什麼是8-Puzzle。\n數字推盤遊戲(n-puzzle)是最早一種的滑塊類遊戲，常見的類型有十五數字推盤遊戲和八數字推盤遊戲等，也有以圖畫代替數字的推盤遊戲。\n Wiki上的8Puzzle \n如上圖所示，滑塊只能往空位移動。\n大概了解遊玩方法後，就來試著解決8-Puzzle問題吧!\n解法的步驟大概是這樣 :\n 先完成移動判斷和節點狀態的儲存結構 用BFS窮舉狀態，並把當前狀態記錄下來篩選重複路徑 只要有一組路徑符合結果，該路徑就是最佳解(因BFS的特性是每次平均向外擴展，所以最先碰到終點的就是最佳解之一) 否則搜尋完畢後皆沒有找到符合的狀態，無解 最後透過父節點的回溯取得輸出路徑，即可得到最短路徑和分解步驟  2. 儲存結構和移動判斷 首先是儲存狀態，用二維陣列來儲存比較直觀，但是用一維陣列來儲存的話，我覺得在一些處理上比較方便，所以我採用一維陣列。\n 資料結構 \n像是上面的這個狀態這樣，將0表示為空格，可以儲存成 { 8, 6, 4, 0, 7, 2, 5, 1, 3}。\n因為要透過BFS搜尋來取得路徑，所以需要建立一個節點的結構，這樣才能儲存當前狀態，並紀錄上個狀態 :\npublic class Node { public byte[] status; // 當前狀態  public Node father; // 紀錄上個狀態，如果father = null 該點為根節點  public Node(byte[] status, Node father) { this.status = status; this.father = father; } // 把陣列轉換成數字序列，比對時就不用兩將陣列元素一一檢查了  // 像是 stauts = {8, 6, 4, 0, 7, 2, 5, 1, 3}，轉後後即可得到864072513  public int ToToSequence() { int result = 0; for (int i = 0; i \u0026lt; status.Length; i++) result = result * 10 + status[i]; return result; } } 再來是移動判斷，滑塊在移動時，可以看成是空白方塊在移動。\n \n如上圖，0 可以往上、右、下移動，但是不能往左，那麼要如何判斷0能往哪個方向走呢?\n \n如上圖，當 index = 3 時，可以得知在二維時座標是 (0, 1)。\n能取得對應位置後，就能夠寫出移動判斷，像是當空位在最左邊時Col = 0，那麼就不能往左走，因為在最左邊了，在最下面時Row = 2，不能往下走，因為已經到底了。\n所以可以得出:\n Col != 0，可以往左走 Col != 2，可以往右走 Row != 0，可以往上走 Row != 2，可以往下走  但是只有判斷能不能走還不夠，因為當空格移動時，必須跟那個位置的數字交換，並記錄下原本的狀態 :\nList\u0026lt;Node\u0026gt; GetNext(Node now)// 傳入當前版面，回傳0所有移動後的狀態 { int index = Array.IndexOf\u0026lt;byte\u0026gt;(now.status, 0); int col = index % 3; int row = index / 3; List\u0026lt;Node\u0026gt; nextPush = new List\u0026lt;Node\u0026gt;(); byte[] next; if (row != 0) // Top  { next = (byte[])now.status.Clone(); swap(ref next[index], ref next[index - 3]);// 跟上面交換  nextPush.Add(new Node(next, now));// 加入這個新狀態  } if (col != 2) // Right  { next = (byte[])now.status.Clone(); swap(ref next[index], ref next[index + 1]);// 跟右邊交換  nextPush.Add(new Node(next, now)); } if (row != 2) // Bottom  { next = (byte[])now.status.Clone(); swap(ref next[index], ref next[index + 3]);// 跟下面交換  nextPush.Add(new Node(next, now)); } if (col != 0) // Left  { next = (byte[])now.status.Clone(); swap(ref next[index], ref next[index - 1]);// 跟左邊交換  nextPush.Add(new Node(next, now)); } return nextPush; } 在交換前要先複製一份，因為陣列參數是傳參考，直接交換會修改到原本的狀態，所以要先Clone後再傳給新狀態做交換。\n而上面程式碼中 new Node(next, now)，意思是建立一個新節點next，而他的前一個狀態是剛剛傳進來的now。\n \n如上圖，假設now是根結點，而next是下個節點，那麼new Node(next, now)後就會像這樣。\n3. 用BFS窮舉狀態 有了移動判段後，接下來的解法就跟用BFS解迷宮差不多了 :\n// 傳入原本的版面和目標版面，回傳最短路徑 List\u0026lt;Node\u0026gt; Solve(byte[] source, byte[] goal) { Queue\u0026lt;Node\u0026gt; queue = new Queue\u0026lt;Node\u0026gt;(); // 使用狀態序列來儲存已走過的路徑，防止往回走  SortedList\u0026lt;int, bool\u0026gt; book = new SortedList\u0026lt;int, bool\u0026gt;(); Node end = new Node(goal, null);// 終點  Node start = new Node(source, null);// 起點  queue.Enqueue(start);// 推入起點  book.Add(start.ToSequence(), true);// 標示起點已走過，防止走回頭路  int endStatus = end.ToSequence(); while (queue.Count \u0026gt; 0) { // 取得當前搜索狀態，並移出佇列  Node now = queue.Dequeue(); // 如果抵達終點，那就輸出路徑  if (now.ToSequence() == endStatus) return PathTrace(now); // 取得能走的位置  List\u0026lt;Node\u0026gt; nextPath = GetNext(now); foreach (var path in nextPath) { int sign = path.ToSequence(); // 判斷當前節點狀態是否擴展過了  if (!book.Keys.Contains(sign)) { // 推入當前狀態，並標記該路徑已走過，因為每個狀態只需要擴展一次就夠了  queue.Enqueue(path); book.Add(sign, true); } } } // 如果窮舉完都沒找到，代表無解  return null; } List\u0026lt;Node\u0026gt; PathTrace(Node now) { // 回朔路徑  List\u0026lt;Node\u0026gt; path = new List\u0026lt;Node\u0026gt;(); while (now.father != null) { path.Add(now); now = now.father; } path.Reverse(); return path; } 路徑的儲存使用SortedList而不是正常的List，因為List在加入物件時並不會特別處理，所以在搜尋時就只能慢慢比較，而 SortedList的結構類似二元搜尋樹，在新增資料時就會依照設定的Key值做排序後再插入，所以在搜尋時的複雜度就能夠降到O(log2 n)，想了解更多的話請看最後的參考資源。\n到這邊大概就能了解為什麼要用ToSequence()來儲存路徑了，因為資料不會重複，所以搭配SortedList就比List快的多。\n使用方法:\nbyte[] source = new byte[] { 8, 6, 4, 0, 7, 2, 5, 1, 3 }; byte[] goal = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 0 }; List\u0026lt;Node\u0026gt; path = Solve(source, goal); Console.WriteLine($\u0026#34;最少步驟為:{path.Count}\u0026#34;); 給定原本面狀態跟輸出狀態，即可得到最短路徑的List，而輸出路徑只要走訪一遍Path即可得到。\n其實執行的原理很簡單，就是一直窮舉所有狀態，直到符合結果為止\n \n4. 執行結果  \nSource Code : Here\n雖然用BFS就能解了，但效率很差，之後會再研究看看A*演算法。\n5. 參考資源  What’s the difference between SortedList and SortedDictionary? : here 各Collection陣列個別特性列表 : here 8-Puzzle : here ACM 15-puzzle : here Inndy GitHub : here  ","date":"2018-06-22T10:04:35+08:00","image":"https://davidhsu666.com/archives/csharp-bfs-solve-8-puzzle/img/8puzzle07.jpg","permalink":"https://davidhsu666.com/archives/csharp-bfs-solve-8-puzzle/","title":"BFS解8-Puzzle問題"},{"content":"浮點數誤差IEEE-754 在程式語言中，浮點數基本都是用 float 與 double來表示，但都會存在誤差\nfloat t1 = 0.69 * 10; cout \u0026lt;\u0026lt; setprecision(32) \u0026lt;\u0026lt; t1 \u0026lt;\u0026lt; endl; if(t1 == 6.9) cout \u0026lt;\u0026lt; \u0026#34;相等\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;不相等\u0026#34; \u0026lt;\u0026lt; endl; // output // =\u0026gt; 6.900000095367431640625 // =\u0026gt; 不相等 正常6.9 * 10 應該要等於6.9，但是答案卻是不相等?\n這個原因跟浮點數的儲存原理有關，讓我們開始吧!\n何謂IEEE-754 自電腦發明以來，曾出現過各種不同的浮點數表示法，但目前最通用的是IEEE二進制運算標準(IEEE Standard for Binary Floating-Point Arithmetic , 簡稱IEEE-754)\n在IEEE-754標準中定義了四種浮點數格式，但我只講基本的兩種，分別為單精準度float(32bit)和雙精準度double(64bit)。其中單精準度有24位有效儲存數字，而雙精準則有53位有效數字，相對於十進位來說，分別是7位(224 = 107)和16位(253 = 1016)。\n為了方便說明，所以先解釋什麼是正規化\n正規化就像是數學中的科學記號，如123456通常會表示成1.23456 x 105，而指數部分也有可能是負的，如 0.123456 就會變成 1.23456 x 10-1。\n二進位的正規化 :\n這邊以13.125為例，先13轉換為2進制，可得1101，再將0.125轉為2進制\n 0.125 x 2 = 0.25 … 整數為0 -\u0026gt; 0 0.25 x 2 =0.5 … 整數為0 -\u0026gt; 0 0.5 x 2 = 1 … 整數為1 -\u0026gt; 1  所以13.125 = 1101.001，經過正規化後可得 1.101001 x 23\n在IEEE-754中，浮點數通常由三個部分組成 :\n 符號(S) : 用來表示正/負(0/1)。 指數(E) : 正規化後的次方數，採用超127格式，即將原本的次方數加上127，因為次方數有可能是負的，加上在電腦中要表示負號時，必須拿一個位元來表示，所以就將-128~+127改為0~255，所以基準點就從0變成127。 尾數(M) : 正規化後的小數點。  以下範例皆為單精準度 :\n \n浮點數與10進制的轉換 以剛剛的 13.125 轉浮點數為例 :\n 由於13.125為正，所以符號(S) = 0 先將數值轉成二進位並正規化 13.125 = 1101.001 = 1.101001 x 23 計算指數(E) = 127 + 3 = 01111111 + 11 = 10000010 計算尾數(M) = 101001，因為正規化後一定是1.xxxx，所以不需要儲存個位數 將各個數值填入浮點數規格中\nS——–E———————M———————–\n0 10000010 101001 0000 0000 0000 0000 0  這樣就就完成了10進制轉IEEE-754浮點數\n而浮點數轉10進制也是一樣\n將剛剛的0 10000010 10100100000000000000000轉10進制 :\n 由於S = 0，所以此數為正 中間8位元的超127指數(E)為 100000102，將其還原130 – 127 = 100000102 – 01111112 可得 3 = 112 所以要將尾數乘上23 最右邊23個為位元值為101001……，將隱藏的個位數還原，可得1.101001…… 最後將還原後的尾數乘上指數 1.1010012 x 23，並轉為10進位，即可得到 13.125  所以我們可以知道，以32bit的單精度浮點數來說，可以儲存的最大位數為 尾數 23+隱藏個位數 1 = 24位。\n關於浮點數的精度 因為有些10進制小數無法完美的用2進制表示，只能用無限的位數來趨近於10進制小數，當我們以24位數為上限時，在儲存時就會省略一些位數，導致還原時的數字不夠精準。\n從以下範例可以得知精確的數字總共7位數\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt;using namespace std; int main() { float t1 = 0.69 * 10; cout \u0026lt;\u0026lt; setprecision(32) \u0026lt;\u0026lt; t1 \u0026lt;\u0026lt; endl; //output =\u0026gt; 6.900000095367431640625  float t2 = 0.1234567; cout \u0026lt;\u0026lt; setprecision(32) \u0026lt;\u0026lt; t2 \u0026lt;\u0026lt; endl; //output =\u0026gt; 0.12345670163631439208984375  float t3 = 123.4567; cout \u0026lt;\u0026lt; setprecision(32) \u0026lt;\u0026lt; t3 \u0026lt;\u0026lt; endl; //output =\u0026gt; 123.45670318603515625 \tfloat t4 = 16777216, t5=0.5; float t6 = t4 + t5; cout \u0026lt;\u0026lt; setprecision(32) \u0026lt;\u0026lt; t6 \u0026lt;\u0026lt; endl; //output =\u0026gt; 16777216  return 0; } 參考資源  IEEE 浮點運算標準 : here C 語言取出/設定浮點數正規化欄位 : here C/C++ 浮點數特殊值 : here [C\u0026amp;C++] 浮點數精準度 (Floating-Point Precision) : here IEEE-754 浮點數的表示法 : here MSDN IEEE 浮點表示 : here Binary floating point and .NET : here What Every Computer Scientist Should Know About Floating-Point Arithmetic : here C语言浮点型数据存储结构 : here IEEE754规范的舍入方案怎么理解呢？ : here  ","date":"2018-05-22T10:29:44+08:00","image":"https://davidhsu666.com/archives/ieee-754/img/ieee754.jpg","permalink":"https://davidhsu666.com/archives/ieee-754/","title":"浮點數誤差IEEE-754"},{"content":"JS 超級球球SuperBall 這小遊戲是我第一個破千行程式碼的專案，前前後後花了2個月左右，花了很多時間在想架構跟遊戲特效的呈現，到目前的進度算是有點成果，放到網站做個記錄。\n遊戲連結 ver.0.2.3 : Click Here\n遊玩方式 移動 : 鍵盤上下左右\n攻擊 : 自動攻擊\n目標 : 通過 8 關\n敵人\n 藍球 : 普通型 紅球 : 速度型 綠球 : 坦克型  這三種敵人都有四種大小，且擁有分裂功能，最多分裂四次\n道具:\n 黃色方塊 : 強化 增加攻擊速度，在累積到一定量時會進化，增加子彈數量，掉落機率10% 白色方塊 : 全屏敵人緩速30%，掉落機率1.5% 紅色方塊 : 補包，增加一格血量，稀有道具，掉落機率0.1%   任務成功   任務失敗 \n 遊戲畫面 \n","date":"2018-03-21T11:05:37+08:00","image":"https://davidhsu666.com/archives/js-superball/img/smallballgame1.png","permalink":"https://davidhsu666.com/archives/js-superball/","title":"JS 超級球球SuperBall"},{"content":"我在網路上搜尋到一些解決方法，在這裡做個整理。\n正常更新畫面的方法都是先將畫面清空後，再將新的畫面畫上去，\n導致清空的剎那，好像畫面閃爍了\n \n解決方法:\n 畫面重繪時，不直接在螢幕上重繪，而是先畫在緩衝區，等整個畫面都重繪完成，才一次放到螢幕上。 想像我們用兩張紙來做更新，一張紙是當前畫面，另一張是緩衝區，在更新時把圖畫在第二章紙上，畫完後再一次把這張紙覆蓋到主畫面。  1.把DoubleBuffered 屬性設為 true。(參考自C# MSDN使用表單和控制項的雙重緩衝)\npublic Form1() { InitializeComponent(); this.DoubleBuffered = true; } 2.使用 BufferedGraphicsContext 。(參考自MSDN手動管理緩衝的圖形)\nfloat x = 0, y = 0; public Form1() { InitializeComponent(); timer1.Interval = 1000 / 60; timer1.Start(); } private void timer1_Tick(object sender, EventArgs e) { x += 1; BufferedGraphicsContext currentContext = BufferedGraphicsManager.Current; BufferedGraphics myBuffer = currentContext.Allocate(this.CreateGraphics(), this.DisplayRectangle); //清除繪圖畫面，並用原本的背景色填充，否則背景呈現黑色  myBuffer.Graphics.Clear(this.BackColor); //在圖形緩衝區中畫圖  myBuffer.Graphics.DrawEllipse(Pens.Blue, x, y, 70, 70); //將圖形緩衝區的內容畫到指定的畫布上  myBuffer.Render(this.CreateGraphics()); //釋放緩衝區的資源  myBuffer.Dispose(); this.Refresh(); this.Invalidate(); } 3.使用Bitmap。(參考自Gary Lin 的 C# 遊戲程式設計)\n較推薦使用這種方式\nfloat x = 0, y = 0; Graphics backGraphics; Bitmap backBmp; public Form1() { InitializeComponent(); backBmp = new Bitmap(this.DisplayRectangle.Width , this.DisplayRectangle.Height); backGraphics = Graphics.FromImage(backBmp); timer1.Interval = 1000 / 60; timer1.Start(); } private void timer1_Tick(object sender, EventArgs e) { //清空畫面，否則前一次的畫面會保留在上面  backGraphics.Clear(Color.White); x+=1; backGraphics.DrawEllipse(Pens.Blue, x, y, 50, 50); //將backBmp上的圖畫到Form上  this.CreateGraphics().DrawImageUnscaled(backBmp, 0, 0); } ","date":"2018-03-21T10:48:34+08:00","image":"https://davidhsu666.com/archives/doublebuffer/img/doublebuffering-wiki.jpg","permalink":"https://davidhsu666.com/archives/doublebuffer/","title":"Doublebuffer雙重緩衝"},{"content":"快速判斷N是否為2的次方數 前陣子遇到一個題目 : 請你判斷一個正整數N是否為2的次方。\n我遇到這題目時，直覺想到的就是，透過迴圈從1開始檢查所有2的次方數，像這樣 :\nbool isPowerBy2_(int n) { for (int i = 1; i \u0026lt;= n; i *= 2) if (i == n) return true; return false; } // output: // isPowerBy2(1) =\u0026gt; true // isPowerBy2(2) =\u0026gt; true // isPowerBy2(4) =\u0026gt; true // isPowerBy2(-1) =\u0026gt; false // isPowerBy2(0) =\u0026gt; false // isPowerBy2(3) =\u0026gt; false 雖然這樣就解決了，但我一直在想是否有效率更高的方法。\n我們先來觀察2的次方數轉成2進制的樣子 :\n1 =\u0026gt; 0000 0001 , 1 – 1 =\u0026gt; 0000 0000 2 =\u0026gt; 0000 0010 , 2 – 1 =\u0026gt; 0000 0001 4 =\u0026gt; 0000 0100 , 4 – 1 =\u0026gt; 0000 0011 8 =\u0026gt; 0000 1000 , 8 – 1 =\u0026gt; 0000 0111 16 =\u0026gt; 0001 0000 , 16 – 1 =\u0026gt; 0000 1111 32 =\u0026gt; 0010 0000 , 32 – 1 =\u0026gt; 0001 1111 可以發現，只要該數是2的次方時，除了MSB(最高位元)是 1 其餘都是0，\n然後我們又可以發現，2的次方數減1後，剛好等於原數NOT後的值。\n在數位邏輯中 N \u0026amp; !N = 0，我們可以透過這個方法來判斷N是否為2的次方，所以是否為2的次方的判斷規則就是 :\nN \u0026amp; (N-1) == 0\n在數學中0不是任何人的次方，但這裡會有個小問題，當我們把0帶入後照樣會得到true，因為0不管和誰做AND都是0，所以要再加上一個 n \u0026gt; 0來塞選。\n最後我們得到\nbool isPowerBy2(int n) { return n \u0026gt; 0 \u0026amp;\u0026amp; (n \u0026amp; n - 1) == 0; } // output: // isPowerBy2(1) =\u0026gt; true // isPowerBy2(2) =\u0026gt; true // isPowerBy2(4) =\u0026gt; true // isPowerBy2(-1) =\u0026gt; false // isPowerBy2(0) =\u0026gt; false // isPowerBy2(3) =\u0026gt; false 那為什麼只要 n \u0026amp; n-1 == 0就代表是2的次方數呢?\n根據上面列出的幾個數字，得出如果該數是2的次方數，就只有MSB為1，而其餘數字都會有2個以上的1，所以在減1時，就不會跟MSB借位，也就沒辦法達到NOT的效果。\n7 = 0111, 7 – 1 = 0110 =\u0026gt; 7 \u0026amp; (7-1) = 110, 110 != 0\n沒辦法達到NOT效果的話，在做AND運算時就不會得到0，只有在該數為2的次方數時，AND的結果才會是零，最後就能透過結果是否為0來判斷N是不是2的次方數了\n","date":"2018-03-21T09:31:46+08:00","permalink":"https://davidhsu666.com/archives/ispowerby2/","title":"快速判斷N是否為2的次方數"},{"content":"這裡是第一篇文章的測試 相簿測試\n Photo1   Photo2   Photo1   Photo2 \n Photo1   Photo2 \n \ncode test\nstd::cout \u0026lt;\u0026lt; \u0026#34;hello world\u0026#34;; ","date":"2015-04-19T03:35:50+08:00","image":"https://davidhsu666.com/archives/just-test/original.gif","permalink":"https://davidhsu666.com/archives/just-test/","title":"JustTest"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code    Code Blocks Code block with backticks \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Fruit  Apple Orange Banana   Dairy  Milk Cheese    Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","date":"2015-03-11T00:00:00Z","image":"https://davidhsu666.com/archives/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://davidhsu666.com/archives/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\n Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so:  {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }}  To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files  Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2015-03-08T00:00:00Z","permalink":"https://davidhsu666.com/archives/math-typesetting/","title":"Math Typesetting"}]